

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Shader Composition &mdash; osgEarth 2.10 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../assets.readthedocs.org/static/javascript/readthedocs-doc-embed.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Coordinate Systems" href="coordinate_systems.html" />
    <link rel="prev" title="Utilities SDK" href="utilities.html" /> 

<!-- RTD Extra Head -->

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="../../latest/developer/shader_composition.html" />

<link rel="stylesheet" href="../../../../assets.readthedocs.org/static/css/readthedocs-doc-embed.css" type="text/css" />

<script type="text/javascript" src="../_static/readthedocs-data.js"></script>

<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "developer/shader_composition"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>

<script type="text/javascript" src="../../../../assets.readthedocs.org/static/javascript/readthedocs-analytics.js"></script>

<!-- end RTD <extrahead> -->
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index-2.html" class="icon icon-home"> osgEarth
          

          
          </a>

          
            
            
            
              <div class="version">
                2.10
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="http://docs.osgearth.org/en/2.10/search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about.html">About the Project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../startup.html">Building osgEarth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Topics</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="maps.html">Working with Maps</a></li>
<li class="toctree-l2"><a class="reference internal" href="utilities.html">Utilities SDK</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Shader Composition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#framework-basics">Framework Basics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#virtualprogram">VirtualProgram</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#adding-functions">Adding Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#shader-packages">Shader Packages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#virtualprogram-metadata">VirtualProgram Metadata</a></li>
<li class="toctree-l4"><a class="reference internal" href="#external-glsl-files">External GLSL Files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-files">Include Files</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#concepts-specific-to-osgearth">Concepts Specific to osgEarth</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#terrain-variables">Terrain Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shared-image-layers">Shared Image Layers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="coordinate_systems.html">Coordinate Systems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Working with Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references/index.html">Reference Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releasenotes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../support.html">osgEarth Priority Support</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index-2.html">osgEarth</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index-2.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Developer Topics</a> &raquo;</li>
        
      <li>Shader Composition</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/gwaldron/osgearth/blob/2.10/docs/source/developer/shader_composition.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="shader-composition">
<h1>Shader Composition<a class="headerlink" href="#shader-composition" title="Permalink to this headline">¶</a></h1>
<p>osgEarth uses GLSL shaders in several of its rendering modes. By default
osgEarth will detect the capabilities of your graphics hardware and
automatically select an appropriate mode to use.</p>
<p>Since osgEarth relies on shaders, you as a developer may wish to customize
the rendering or add your own effects and features in GLSL. Anyone who has
worked with shaders has run into the same challenges:</p>
<ul class="simple">
<li>Shader programs are monolithic. Adding new shader code requires you to
copy, modify, and replace the existing code so you don’t lose its
functionality.</li>
<li>Keeping your changes in sync with changes to the original code’s
shaders is a maintenance nightmare.</li>
<li>Maintaining multiple versions of shader main()s is cumbersome and
difficult.</li>
<li>Maintaining the dreaded “uber shader” becomes unmanageable as the
GLSL code base grows in complexity and you add more features.</li>
</ul>
<p><em>Shader Composition</em> solves these problems by <em>modularizing</em> the shader
pipeline. You can add and remove <em>functions</em> at any point in the program
without copying, pasting, or hacking other people’s GLSL code.</p>
<p>Next we will discuss the structure of osgEarth’s shader composition framework.</p>
<div class="section" id="framework-basics">
<h2>Framework Basics<a class="headerlink" href="#framework-basics" title="Permalink to this headline">¶</a></h2>
<p>The Shader Composition framework provides the main() functions automatically.
You do not need to write them. Instead, you write modular functions and tell the
framework when and where to execute them.</p>
<p>Below you can see the main() functions that osgEarth creates.
The <code class="docutils literal notranslate"><span class="pre">LOCATION_*</span></code> designators allow you to inject functions at
various points in the shader’s execution pipeline.</p>
<p>Here is the pseudo-code for osgEarth’s built-in shaders mains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">VERTEX</span> <span class="n">SHADER</span><span class="p">:</span>

<span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vec4</span> <span class="n">vertex</span> <span class="o">=</span> <span class="n">gl_Vertex</span><span class="p">;</span>

    <span class="o">//</span> <span class="s2">&quot;LOCATION_VERTEX_MODEL&quot;</span> <span class="n">user</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">called</span> <span class="n">here</span><span class="p">:</span>
    <span class="n">model_func_1</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">model_func_2</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
    <span class="o">...</span>

    <span class="n">vertex</span> <span class="o">=</span> <span class="n">gl_ModelViewMatrix</span> <span class="o">*</span> <span class="n">vertex</span><span class="p">;</span>

    <span class="o">//</span> <span class="s2">&quot;LOCATION_VERTEX_VIEW&quot;</span> <span class="n">user</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">called</span> <span class="n">here</span><span class="p">:</span>
    <span class="n">view_func_1</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
    <span class="o">...</span>

    <span class="n">vertex</span> <span class="o">=</span> <span class="n">gl_ProjectionMatrix</span> <span class="o">*</span> <span class="n">vertex</span><span class="p">;</span>

    <span class="o">//</span> <span class="s2">&quot;LOCATION_VERTEX_CLIP&quot;</span> <span class="n">user</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">called</span> <span class="n">last</span><span class="p">:</span>
    <span class="n">clip_func_1</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
    <span class="o">...</span>

    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">;</span>
<span class="p">}</span>


<span class="o">//</span> <span class="n">FRAGMENT</span> <span class="n">SHADER</span><span class="p">:</span>

<span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vec4</span> <span class="n">color</span> <span class="o">=</span> <span class="n">gl_Color</span><span class="p">;</span>
    <span class="o">...</span>

    <span class="o">//</span> <span class="s2">&quot;LOCATION_FRAGMENT_COLORING&quot;</span> <span class="n">user</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">called</span> <span class="n">here</span><span class="p">:</span>
    <span class="n">coloring_func_1</span><span class="p">(</span><span class="n">color</span><span class="p">);</span>
    <span class="o">...</span>

    <span class="o">//</span> <span class="s2">&quot;LOCATION_FRAGMENT_LIGHTING&quot;</span> <span class="n">user</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">called</span> <span class="n">here</span><span class="p">:</span>
    <span class="n">lighting_func_1</span><span class="p">(</span><span class="n">color</span><span class="p">);</span>
    <span class="o">...</span>

    <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can see, we have made the design decision to designate function
injection points that make sense for <em>most</em> applications. That is not to say
that they are perfect for everything, rather that we believe this approach
makes the Framework easy to use and not too “low-level”.</p>
<p><em>Important</em>: The Shader Composition Framework at this time only supports VERTEX and FRAGMENT
shaders. It does not support GEOMETRY or TESSELLATION shaders yet. We are planning
to add this in the future.</p>
</div>
<div class="section" id="virtualprogram">
<h2>VirtualProgram<a class="headerlink" href="#virtualprogram" title="Permalink to this headline">¶</a></h2>
<p>osgEarth introduces a new OSG state attribute called <code class="docutils literal notranslate"><span class="pre">VirtualProgram</span></code> that performs
the runtime shader composition. Since <code class="docutils literal notranslate"><span class="pre">VirtualProgram</span></code> is an <code class="docutils literal notranslate"><span class="pre">osg::StateAttribute</span></code>,
you can attach one to any node in the scene graph. Shaders that belong to a
<code class="docutils literal notranslate"><span class="pre">VirtualProgram</span></code> can override shaders higher up in the scene graph.
In this way you can add, combine, and override individual shader functions in osgEarth.</p>
<p>At run time, a <code class="docutils literal notranslate"><span class="pre">VirtualProgram</span></code> will look at the current state and assemble a full
<code class="docutils literal notranslate"><span class="pre">osg::Program</span></code> that uses the built-in main()s and calls all the functions that you
have injected via <code class="docutils literal notranslate"><span class="pre">VirtualProgram</span></code>.</p>
<div class="section" id="adding-functions">
<h3>Adding Functions<a class="headerlink" href="#adding-functions" title="Permalink to this headline">¶</a></h3>
<p>From the generated mains we saw earlier, osgEarth calls into user functions.
These don’t exist in the default shaders that osgEarth generates;
rather, they represent code that you as the developer can “inject”
into various locations in the shader pipeline.</p>
<p>For example, let’s use user functions to create a simple “haze” effect:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">haze_vertex</span><span class="p">:</span>
<span class="n">out</span> <span class="n">vec3</span> <span class="n">v_pos</span><span class="p">;</span>
<span class="n">void</span> <span class="n">setup_haze</span><span class="p">(</span><span class="n">inout</span> <span class="n">vec4</span> <span class="n">vertexView</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">v_pos</span> <span class="o">=</span> <span class="n">vertexView</span><span class="o">.</span><span class="n">xyz</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">haze_fragment</span><span class="p">:</span>
<span class="ow">in</span> <span class="n">vec3</span> <span class="n">v_pos</span><span class="p">;</span>
<span class="n">void</span> <span class="n">apply_haze</span><span class="p">(</span><span class="n">inout</span> <span class="n">vec4</span> <span class="n">color</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nb">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span> <span class="n">length</span><span class="p">(</span><span class="n">v_pos</span><span class="p">)</span><span class="o">/</span><span class="mf">10000000.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.75</span> <span class="p">);</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">dist</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">C</span><span class="o">++</span><span class="p">:</span>
<span class="n">VirtualProgram</span><span class="o">*</span> <span class="n">vp</span> <span class="o">=</span> <span class="n">VirtualProgram</span><span class="p">::</span><span class="n">getOrCreate</span><span class="p">(</span> <span class="n">stateSet</span> <span class="p">);</span>

<span class="n">vp</span><span class="o">-&gt;</span><span class="n">setFunction</span><span class="p">(</span> <span class="s2">&quot;setup_haze&quot;</span><span class="p">,</span> <span class="n">haze_vertex</span><span class="p">,</span>   <span class="n">ShaderComp</span><span class="p">::</span><span class="n">LOCATION_VERTEX_VIEW</span><span class="p">);</span>
<span class="n">vp</span><span class="o">-&gt;</span><span class="n">setFunction</span><span class="p">(</span> <span class="s2">&quot;apply_haze&quot;</span><span class="p">,</span> <span class="n">haze_fragment</span><span class="p">,</span> <span class="n">ShaderComp</span><span class="p">::</span><span class="n">LOCATION_FRAGMENT_LIGHTING</span><span class="p">);</span>
</pre></div>
</div>
<p>In this example, the function <code class="docutils literal notranslate"><span class="pre">setup_haze</span></code> is called from the built-in vertex shader
main() after the built-in vertex functions. The <code class="docutils literal notranslate"><span class="pre">apply_haze</span></code> function gets called from
the core fragment shader main() after the built-in fragment functions.</p>
<p>There are SIX injection points, as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="16%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Location</th>
<th class="head">Shader Type</th>
<th class="head">Signature</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ShaderComp::LOCATION_VERTEX_MODEL</td>
<td>VERTEX</td>
<td>void func(inout vec4 vertex)</td>
</tr>
<tr class="row-odd"><td>ShaderComp::LOCATION_VERTEX_VIEW</td>
<td>VERTEX</td>
<td>void func(inout vec4 vertex)</td>
</tr>
<tr class="row-even"><td>ShaderComp::LOCATION_VERTEX_CLIP</td>
<td>VERTEX</td>
<td>void func(inout vec4 vertex)</td>
</tr>
<tr class="row-odd"><td>ShaderComp::LOCATION_FRAGMENT_COLORING</td>
<td>FRAGMENT</td>
<td>void func(inout vec4 color)</td>
</tr>
<tr class="row-even"><td>ShaderComp::LOCATION_FRAGMENT_LIGHTING</td>
<td>FRAGMENT</td>
<td>void func(inout vec4 color)</td>
</tr>
<tr class="row-odd"><td>ShaderComp::LOCATION_FRAGMENT_OUTPUT</td>
<td>FRAGMENT</td>
<td>void func(inout vec4 color)</td>
</tr>
</tbody>
</table>
<p>Each VERTEX locations let you operate on the vertex in a particular <em>coordinate space</em>.
You can alter the vertex, but you <em>must</em> leave it in the same space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">MODEL:</th><td class="field-body">Vertex is the raw, untransformed values from the geometry.</td>
</tr>
<tr class="field-even field"><th class="field-name">VIEW:</th><td class="field-body">Vertex is relative to the eyepoint, which lies at the origin (0,0,0) and
points down the -Z axis. In VIEW space, the original vertex has been
transformed by <code class="docutils literal notranslate"><span class="pre">gl_ModelViewMatrix</span></code>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">CLIP:</th><td class="field-body">Post-projected clip space. CLIP space lies in the [-w..w] range along all
three axis, and is the result of transforming the original vertex by
<code class="docutils literal notranslate"><span class="pre">gl_ModelViewProjectionMatrix</span></code>.</td>
</tr>
</tbody>
</table>
<p>The FRAGMENT locations are as follows.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">COLORING:</th><td class="field-body">Functions here are called when resolving the fragment color before
lighting is applied. Texturing or color adjustments typically
happen during this stage.</td>
</tr>
<tr class="field-even field"><th class="field-name">LIGHTING:</th><td class="field-body">Functions here affect the lighting applied to a fragment color. This is
where things like sun lighting, bump mapping or normal mapping would
typically occur.</td>
</tr>
<tr class="field-odd field"><th class="field-name">OUTPUT:</th><td class="field-body">This is where gl_FragColor is set. By default, the built-in fragment
main() will set it for you. But you can set an OUTPUT shader to
replace this behavior with your own. A typical reason to do this would
be to implement MRT rendering (see the osgearth_mrt example).</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="shader-packages">
<h2>Shader Packages<a class="headerlink" href="#shader-packages" title="Permalink to this headline">¶</a></h2>
<p>Earlier we showed you how to inject functions using <code class="docutils literal notranslate"><span class="pre">VirtualProgram</span></code>.
The Shader Composition Framework also provides the concept of a <code class="docutils literal notranslate"><span class="pre">ShaderPackage</span></code> that supports
more advanced methods of shader management. We will talk about some of those now.</p>
<div class="section" id="virtualprogram-metadata">
<h3>VirtualProgram Metadata<a class="headerlink" href="#virtualprogram-metadata" title="Permalink to this headline">¶</a></h3>
<p>As we have seen, when you add a shader function to the pipeline using <code class="docutils literal notranslate"><span class="pre">VirtualProgram</span></code>
you need to tell osgEarth the name of the GLSL function to call, and the location in
the pipeline at which to call it, like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VirtualProgram</span><span class="o">*</span> <span class="n">vp</span><span class="p">;</span>
<span class="o">....</span>
<span class="n">vp</span><span class="o">-&gt;</span><span class="n">setFunction</span><span class="p">(</span> <span class="s2">&quot;color_it_red&quot;</span><span class="p">,</span> <span class="n">shaderSource</span><span class="p">,</span> <span class="n">ShaderComp</span><span class="p">::</span><span class="n">LOCATION_FRAGMENT_COLORING</span> <span class="p">);</span>
</pre></div>
</div>
<p>That works. But if the function name or the inject location changes, you need to remember
to keep the GLSL code in sync with the <code class="docutils literal notranslate"><span class="pre">setFunction()</span></code> parameters.</p>
<p>It would be easier to specify this all in once place. A <code class="docutils literal notranslate"><span class="pre">ShaderPackage</span></code> lets you do just that.
Here is an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#version 110</span>

<span class="c1">#pragma vp_entryPoint  color_it_red</span>
<span class="c1">#pragma vp_location    fragment_coloring</span>
<span class="c1">#pragma vp_order       1.0</span>

<span class="n">void</span> <span class="n">color_it_red</span><span class="p">(</span><span class="n">inout</span> <span class="n">vec4</span> <span class="n">color</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">color</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now instead of calling <code class="docutils literal notranslate"><span class="pre">VirtualProgram::setFunction()</span></code> directory, you can create a
<code class="docutils literal notranslate"><span class="pre">ShaderPackage</span></code>, add your code, and call load to create the function on the <code class="docutils literal notranslate"><span class="pre">VirtualProgram</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ShaderPackage</span> <span class="n">package</span><span class="p">;</span>
<span class="n">package</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">shaderFileName</span><span class="p">,</span> <span class="n">shaderSource</span> <span class="p">);</span>
<span class="n">package</span><span class="o">.</span><span class="n">load</span><span class="p">(</span> <span class="n">virtualProgram</span><span class="p">,</span> <span class="n">shaderFileName</span> <span class="p">);</span>
</pre></div>
</div>
<p>It takes a “file name” because the shader can be in an external file.
But that is not a requirement. Read on for more details.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">vp_location</span></code> values follow the code-based values, and are as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vertex_model</span>
<span class="n">vertex_view</span>
<span class="n">vertex_clip</span>
<span class="n">fragment_coloring</span>
<span class="n">fragment_lighting</span>
<span class="n">fragment_output</span>
</pre></div>
</div>
</div>
<div class="section" id="external-glsl-files">
<h3>External GLSL Files<a class="headerlink" href="#external-glsl-files" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ShaderPackage</span></code> lets you load GLSL code from either a file or a string.
When you call the <code class="docutils literal notranslate"><span class="pre">add</span></code> method as show above, this tells the package to
(a) first look for a file by that name and load from that file; and
(b) if the file doesn’t exist, use the code in the source string.</p>
<p>So let’s look at this example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ShaderPackage</span> <span class="n">package</span><span class="p">;</span>
<span class="n">package</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="s2">&quot;myshader.frag.glsl&quot;</span><span class="p">,</span> <span class="n">backupSourceCode</span> <span class="p">);</span>
<span class="o">...</span>
<span class="n">package</span><span class="o">.</span><span class="n">load</span><span class="p">(</span> <span class="n">virtualProgram</span><span class="p">,</span> <span class="s2">&quot;myshader.frag.glsl&quot;</span> <span class="p">);</span>
</pre></div>
</div>
<p>The package will try to load the shader from the GLSL file. It will search for it in the <code class="docutils literal notranslate"><span class="pre">OSG_FILE_PATH</span></code>.
If it cannot find the file, it will load the shader from the backup source code associated with
that shader in the package.</p>
<p>osgEarth uses this technique internally to “inline” its stock shader code.
That gives you the option of deploying GLSL files with your application OR
keeping them inline – the application will still work either way.</p>
</div>
<div class="section" id="include-files">
<h3>Include Files<a class="headerlink" href="#include-files" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ShaderPackage</span></code> support the concept if <em>include files</em>. Your GLSL code
can <em>include</em> any other shaders in the same package by referencing their file names.
Use a custom <code class="docutils literal notranslate"><span class="pre">#pragma</span></code> to include another file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#pragma include myCode.vertex.glsl</span>
</pre></div>
</div>
<p>Just as in C++, the <em>include</em> will load the other file (or source code) directly
inline. So the file you are including must be structured as if you had placed it right
in the including file. (That means it cannot have its own <code class="docutils literal notranslate"><span class="pre">#version</span></code> string, for example.)</p>
<p>Again: the <em>includer</em> and the <em>includee</em> must be registered with the same <code class="docutils literal notranslate"><span class="pre">ShaderPackage</span></code>.</p>
</div>
</div>
<hr class="docutils" />
<div class="section" id="concepts-specific-to-osgearth">
<h2>Concepts Specific to osgEarth<a class="headerlink" href="#concepts-specific-to-osgearth" title="Permalink to this headline">¶</a></h2>
<p>Even though the VirtualProgram framework is included in the osgEarth SDK,
it really has nothing to do with map rendering. In this section we will go over some
of the things that osgEarth does with shader composition.</p>
<div class="section" id="terrain-variables">
<h3>Terrain Variables<a class="headerlink" href="#terrain-variables" title="Permalink to this headline">¶</a></h3>
<p>There are some built-in shader <code class="docutils literal notranslate"><span class="pre">uniforms</span></code> and <code class="docutils literal notranslate"><span class="pre">variables</span></code> that the osgEarth terrain
engine uses and that are available to the developer.</p>
<blockquote>
<div><em>Important: Shader variables starting with the prefix ``oe_`` or ``osgearth_``
are reserved for osgEarth internal use.</em></div></blockquote>
<p>Uniforms:</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">oe_tile_key:</th><td class="field-body">(vec4) elements 0-2 hold the x, y, and LOD tile key values;
element 3 holds the tile’s bounding sphere radius (in meters)</td>
</tr>
<tr class="field-even field"><th class="field-name">oe_layer_tex:</th><td class="field-body">(sampler2D) texture applied to the current layer of the current tile</td>
</tr>
<tr class="field-odd field"><th class="field-name">oe_layer_texc:</th><td class="field-body">(vec4) texture coordinates for current tile</td>
</tr>
<tr class="field-even field"><th class="field-name">oe_layer_tilec:</th><td class="field-body">(vec4) unit coordinates for the current tile (0..1 in x and y)</td>
</tr>
<tr class="field-odd field"><th class="field-name">oe_layer_uid:</th><td class="field-body">(int) Unique ID of the active layer</td>
</tr>
<tr class="field-even field"><th class="field-name">oe_layer_order:</th><td class="field-body">(int) Render order of the active layer</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">oe_layer_opacity:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">(float) Opacity [0..1] of the active layer</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Vertex attributes:</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">oe_terrain_attr:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">(vec4) elements 0-2 hold the unit height vector for a terrain
vertex, and element 3 holds the raw terrain elevation value</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">oe_terrain_attr2:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">(vec4) element 0 holds the <em>parent</em> tile’s elevation value;
elements 1-3 are currently unused.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="shared-image-layers">
<h3>Shared Image Layers<a class="headerlink" href="#shared-image-layers" title="Permalink to this headline">¶</a></h3>
<p>Sometimes you want to access more than one image layer at a time.
For example, you might have a masking layer that indicates land vs. water.
You may not actually want to <em>draw</em> this layer, but you want to use it to modulate
another visible layer.</p>
<p>You can do this using <em>shared image layers</em>. In the <code class="docutils literal notranslate"><span class="pre">Map</span></code>, mark an image layer as
<em>shared</em> (using <code class="docutils literal notranslate"><span class="pre">ImageLayerOptions::shared()</span></code>) and the renderer will make it available
to all the other layers in a secondary sampler.</p>
<blockquote>
<div>Please refer to <code class="docutils literal notranslate"><span class="pre">osgearth_sharedlayer.cpp</span></code> for a usage example!</div></blockquote>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="coordinate_systems.html" class="btn btn-neutral float-right" title="Coordinate Systems" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="utilities.html" class="btn btn-neutral float-left" title="Utilities SDK" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Pelican Mapping
      
        <span class="commit">
          Revision <code>de6041a2</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org/">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: 2.10
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="../../latest/index.html">latest</a></dd>
        
          <dd><a href="../../3.0/index.html">3.0</a></dd>
        
          <dd><a href="../index.html">2.10</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="http://readthedocs.org/projects/osgearth/downloads/pdf/2.10/">pdf</a></dd>
        
          <dd><a href="http://readthedocs.org/projects/osgearth/downloads/htmlzip/2.10/">html</a></dd>
        
          <dd><a href="http://readthedocs.org/projects/osgearth/downloads/epub/2.10/">epub</a></dd>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="http://readthedocs.org/projects/osgearth/?fromdocs=osgearth">Project Home</a>
          </dd>
          <dd>
            <a href="http://readthedocs.org/builds/osgearth/?fromdocs=osgearth">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org/">Read the Docs</a>.

    </div>
  </div>



  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
   

</body>
</html>