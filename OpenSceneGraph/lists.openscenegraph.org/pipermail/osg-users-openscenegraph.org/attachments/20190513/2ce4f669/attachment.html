<tt>
&lt;div&nbsp;dir=&quot;ltr&quot;&gt;&lt;div&nbsp;dir=&quot;ltr&quot;&gt;&lt;div&nbsp;dir=&quot;ltr&quot;&gt;&lt;div&nbsp;dir=&quot;ltr&quot;&gt;&lt;div&nbsp;dir=&quot;ltr&quot;&gt;&lt;div&nbsp;dir=&quot;ltr&quot;&gt;&lt;div&nbsp;dir=&quot;ltr&quot;&gt;&lt;div&nbsp;dir=&quot;ltr&quot;&gt;&lt;div&nbsp;dir=&quot;ltr&quot;&gt;&lt;div&nbsp;dir=&quot;ltr&quot;&gt;&lt;div&gt;Hello,&lt;/div&gt;&lt;div&gt;In&nbsp;my&nbsp;project,&nbsp;I&nbsp;need&nbsp;to&nbsp;render&nbsp;an&nbsp;OSG&nbsp;frame&nbsp;without&nbsp;any&nbsp;window&nbsp;appearing&nbsp;on&nbsp;the&nbsp;screen.&nbsp;So&nbsp;called&nbsp;&quot;off&nbsp;screen&quot;.&lt;/div&gt;&lt;div&gt;In&nbsp;order&nbsp;to&nbsp;do&nbsp;that,&nbsp;I&nbsp;found&nbsp;the&nbsp;following&nbsp;code&nbsp;taken&nbsp;osgprerenderer.cpp&nbsp;that&nbsp;I&nbsp;intend&nbsp;to&nbsp;inspire&nbsp;from&nbsp;if&nbsp;I&nbsp;can&nbsp;make&nbsp;it&nbsp;work&nbsp;correctly:&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;AsyncRTTViewer&nbsp;class:&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;/*&nbsp;-*-c++-*-&nbsp;Taken&nbsp;from&nbsp;osgprerenderer.cpp&lt;br&gt; *&lt;br&gt; *&nbsp;This&nbsp;application&nbsp;is&nbsp;open&nbsp;source&nbsp;and&nbsp;may&nbsp;be&nbsp;redistributed&nbsp;and/or&nbsp;modified  &nbsp;&lt;br&gt; *&nbsp;freely&nbsp;and&nbsp;without&nbsp;restriction,&nbsp;both&nbsp;in&nbsp;commericial&nbsp;and&nbsp;non&nbsp;commericial&nbsp;applications,&lt;br&gt; *&nbsp;as&nbsp;long&nbsp;as&nbsp;this&nbsp;copyright&nbsp;notice&nbsp;is&nbsp;maintained.&lt;br&gt; *&nbsp;&lt;br&gt; *&nbsp;This&nbsp;application&nbsp;is&nbsp;distributed&nbsp;in&nbsp;the&nbsp;hope&nbsp;that&nbsp;it&nbsp;will&nbsp;be&nbsp;useful,&lt;br&gt; *&nbsp;but&nbsp;WITHOUT&nbsp;ANY&nbsp;WARRANTY;&nbsp;without&nbsp;even&nbsp;the&nbsp;implied&nbsp;warranty&nbsp;of&lt;br&gt; *&nbsp;MERCHANTABILITY&nbsp;or&nbsp;FITNESS&nbsp;FOR&nbsp;A&nbsp;PARTICULAR&nbsp;PURPOSE.&lt;br&gt;&lt;br&gt; g++&nbsp;-losgShadow&nbsp;-losgText&nbsp;-losgUtil&nbsp;-losgViewer&nbsp;-losgGA&nbsp;-lOpenThreads&nbsp;-losg&nbsp;-lGL&nbsp;-lGLU&nbsp;-lglut&nbsp;async_test.cpp&lt;br&gt;&lt;br&gt;*/&lt;br&gt;#include&nbsp;&lt;osgDB/ReadFile&gt;&lt;br&gt;#include&nbsp;&lt;osgDB/WriteFile&gt;&lt;br&gt;&lt;br&gt;#include&nbsp;&lt;osgUtil/Optimizer&gt;&lt;br&gt;#include&nbsp;&lt;osg/CoordinateSystemNode&gt;&lt;br&gt;&lt;br&gt;#include&nbsp;&lt;osg/Switch&gt;&lt;br&gt;#include&nbsp;&lt;osgText/Text&gt;&lt;br&gt;&lt;br&gt;#include&nbsp;&lt;osgViewer/Viewer&gt;&lt;br&gt;#include&nbsp;&lt;osgViewer/ViewerEventHandlers&gt;&lt;br&gt;#include&nbsp;&lt;osgViewer/Renderer&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;#include&nbsp;&lt;osgGA/TrackballManipulator&gt;&lt;br&gt;#include&nbsp;&lt;osgGA/FlightManipulator&gt;&lt;br&gt;#include&nbsp;&lt;osgGA/DriveManipulator&gt;&lt;br&gt;#include&nbsp;&lt;osgGA/KeySwitchMatrixManipulator&gt;&lt;br&gt;#include&nbsp;&lt;osgGA/StateSetManipulator&gt;&lt;br&gt;&lt;br&gt;#include&nbsp;&lt;iostream&gt;&lt;br&gt;#include&nbsp;&lt;sstream&gt;&lt;br&gt;#include&nbsp;&lt;string.h&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;class&nbsp;AsyncRTTViewer&nbsp;:&nbsp;public&nbsp;osgViewer::Viewer&nbsp;{&lt;br&gt;public:&lt;br&gt;   &nbsp;&lt;br&gt; &nbsp;AsyncRTTViewer(){&lt;br&gt;   &nbsp;asyncRTTViewerConstructorInit();&lt;br&gt; &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;AsyncRTTViewer(osg::ArgumentParser&amp;&nbsp;arguments)&lt;br&gt;   &nbsp;:&nbsp;osgViewer::Viewer(arguments)&nbsp;{&lt;br&gt;   &nbsp;asyncRTTViewerConstructorInit();&lt;br&gt; &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;AsyncRTTViewer(const&nbsp;osgViewer::Viewer&amp;&nbsp;viewer,&nbsp;&lt;br&gt;                &nbsp;const&nbsp;osg::CopyOp&amp;&nbsp;copyop=osg::CopyOp::SHALLOW_COPY) &nbsp;&lt;br&gt;   &nbsp;:&nbsp;osgViewer::Viewer(viewer,copyop)&nbsp;{&lt;br&gt;   &nbsp;asyncRTTViewerConstructorInit();&lt;br&gt; &nbsp;}&lt;br&gt;   &nbsp;&lt;br&gt; &nbsp;virtual&nbsp;~AsyncRTTViewer()&nbsp;{}&lt;br&gt;&lt;br&gt; &nbsp;///&nbsp;adds&nbsp;a&nbsp;render&nbsp;to&nbsp;texture&nbsp;camera&nbsp;&lt;br&gt; &nbsp;void&nbsp;addOffScreenRTTNode(osg::Node*&nbsp;node){&lt;br&gt;   &nbsp;offScreenNodes-&gt;addChild(node);&lt;br&gt; &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;///&nbsp;removes&nbsp;a&nbsp;render&nbsp;to&nbsp;texture&nbsp;camera&nbsp;&lt;br&gt; &nbsp;void&nbsp;removeOffScreenRTTNode(osg::Node*&nbsp;node){&lt;br&gt;   &nbsp;offScreenNodes-&gt;removeChild(node); &nbsp;&lt;br&gt; &nbsp;}&lt;br&gt;   &nbsp;&lt;br&gt; &nbsp;/**&nbsp;call&nbsp;this&nbsp;function&nbsp;to&nbsp;render&nbsp;the&nbsp;off&nbsp;screen&nbsp;scene.&lt;br&gt;     &nbsp;If&nbsp;no&nbsp;off&nbsp;screen&nbsp;nodes&nbsp;(RTT)&nbsp;are&nbsp;supplied&nbsp;than&nbsp;nothing&nbsp;is&nbsp;done     &nbsp;&lt;br&gt; &nbsp;*/&lt;br&gt; &nbsp;virtual&nbsp;void&nbsp;renderOffScreen(&nbsp;)&nbsp;{&lt;br&gt;   &nbsp;if&nbsp;(_done&nbsp;||&nbsp;offScreenNodes-&gt;getNumChildren()&nbsp;==&nbsp;0)&nbsp;return;&lt;br&gt;     &nbsp;&lt;br&gt;   &nbsp;osg::Node*&nbsp;origNode&nbsp;=&nbsp;_camera-&gt;getChild(0);&lt;br&gt;   &nbsp;_camera-&gt;setChild(0,offScreenNodes);&lt;br&gt;   &nbsp;//   &nbsp;printf(&quot;before&nbsp;offscreen\n&quot;);   &nbsp;&lt;br&gt;   &nbsp;offScreenRenderingTraversals();&lt;br&gt;   &nbsp;//printf(&quot;after&nbsp;offscreen\n&quot;);&lt;br&gt;   &nbsp;_camera-&gt;setChild(0,origNode);&lt;br&gt; &nbsp;}&lt;br&gt;&lt;br&gt;protected:&lt;br&gt;   &nbsp;&lt;br&gt;&lt;br&gt; &nbsp;virtual&nbsp;void&nbsp;offScreenRenderingTraversals()&nbsp;{       &nbsp;&lt;br&gt;     &nbsp;&lt;br&gt;   &nbsp;/***&nbsp;This&nbsp;is&nbsp;copied&nbsp;from&nbsp;ViewerBase::renderingTraversals()&nbsp;and&nbsp;&lt;br&gt;        &nbsp;statistics&nbsp;and&nbsp;swapbuffer&nbsp;and&nbsp;so&nbsp;on&nbsp;are&nbsp;removed.      &nbsp;&lt;br&gt;   &nbsp;*/&lt;br&gt;     &nbsp;&lt;br&gt;   &nbsp;if&nbsp;(_done)&nbsp;return;&lt;br&gt;     &nbsp;&lt;br&gt;   &nbsp;offScreenNodes-&gt;getBound();&lt;br&gt;     &nbsp;&lt;br&gt;   &nbsp;Contexts&nbsp;contexts;&lt;br&gt;   &nbsp;getContexts(contexts);&lt;br&gt;     &nbsp;&lt;br&gt;   &nbsp;Cameras&nbsp;cameras;&lt;br&gt;   &nbsp;getCameras(cameras);&lt;br&gt;     &nbsp;&lt;br&gt;   &nbsp;Contexts::iterator&nbsp;itr;&lt;br&gt;     &nbsp;&lt;br&gt;   &nbsp;bool&nbsp;doneMakeCurrentInThisThread&nbsp;=&nbsp;false;&lt;br&gt;     &nbsp;&lt;br&gt;   &nbsp;if&nbsp;(_endDynamicDrawBlock.valid())&lt;br&gt;     &nbsp;{&lt;br&gt;       &nbsp;_endDynamicDrawBlock-&gt;reset();&lt;br&gt;     &nbsp;}&lt;br&gt;     &nbsp;&lt;br&gt;   &nbsp;//&nbsp;dispatch&nbsp;the&nbsp;rendering&nbsp;threads&lt;br&gt;   &nbsp;if&nbsp;(_startRenderingBarrier.valid())&nbsp;_startRenderingBarrier-&gt;block();&lt;br&gt;     &nbsp;&lt;br&gt;   &nbsp;//&nbsp;reset&nbsp;any&nbsp;double&nbsp;buffer&nbsp;graphics&nbsp;objects&lt;br&gt;   &nbsp;for(Cameras::iterator&nbsp;camItr&nbsp;=&nbsp;cameras.begin();&lt;br&gt;       &nbsp;camItr&nbsp;!=&nbsp;cameras.end();&lt;br&gt;       &nbsp;++camItr)&lt;br&gt;     &nbsp;{&lt;br&gt;       &nbsp;osg::Camera*&nbsp;camera&nbsp;=&nbsp;*camItr;&lt;br&gt;       &nbsp;osgViewer::Renderer*&nbsp;renderer&nbsp;=&nbsp;dynamic_cast&lt;osgViewer::Renderer*&gt;(camera-&gt;getRenderer());&lt;br&gt;       &nbsp;if&nbsp;(renderer)&lt;br&gt;         &nbsp;{&lt;br&gt;           &nbsp;if&nbsp;(!renderer-&gt;getGraphicsThreadDoesCull()&nbsp;&amp;&amp;&nbsp;!(camera-&gt;getCameraThread()))&lt;br&gt;             &nbsp;{&lt;br&gt;               &nbsp;renderer-&gt;cull();&lt;br&gt;             &nbsp;}&lt;br&gt;         &nbsp;}&lt;br&gt;         &nbsp;&lt;br&gt;     &nbsp;}&lt;br&gt;     &nbsp;&lt;br&gt;   &nbsp;for(itr&nbsp;=&nbsp;contexts.begin();&lt;br&gt;       &nbsp;itr&nbsp;!=&nbsp;contexts.end();&lt;br&gt;       &nbsp;++itr)&lt;br&gt;     &nbsp;{&lt;br&gt;       &nbsp;if&nbsp;(_done)&nbsp;return;&lt;br&gt;       &nbsp;if&nbsp;(!((*itr)-&gt;getGraphicsThread())&nbsp;&amp;&amp;&nbsp;(*itr)-&gt;valid())&lt;br&gt;         &nbsp;{&lt;br&gt;           &nbsp;doneMakeCurrentInThisThread&nbsp;=&nbsp;true;&nbsp;&lt;br&gt;           &nbsp;makeCurrent(*itr);&lt;br&gt;           &nbsp;(*itr)-&gt;runOperations();&lt;br&gt;         &nbsp;}&lt;br&gt;     &nbsp;}&lt;br&gt;&lt;br&gt;   &nbsp;/*for&nbsp;(itr&nbsp;=&nbsp;contexts.begin();&lt;br&gt;   &nbsp;   &nbsp;itr&nbsp;!=&nbsp;contexts.end()&nbsp;&amp;&amp;&nbsp;!_done;&lt;br&gt;   &nbsp;   &nbsp;++itr)&lt;br&gt;   &nbsp;{&lt;br&gt;   &nbsp;   &nbsp;if&nbsp;(!((*itr)-&gt;getGraphicsThread())&nbsp;&amp;&amp;&nbsp;(*itr)-&gt;valid())&lt;br&gt;   &nbsp;   &nbsp;{&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;doneMakeCurrentInThisThread&nbsp;=&nbsp;true;&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;makeCurrent(*itr);&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;(*itr)-&gt;swapBuffers();&lt;br&gt;   &nbsp;   &nbsp;}&lt;br&gt;   &nbsp;}*/&lt;br&gt;&lt;br&gt;   &nbsp;//&nbsp;osg::notify(osg::NOTICE)&lt;&lt;&quot;Joing&nbsp;_endRenderingDispatchBarrier&nbsp;block&nbsp;&quot;&lt;&lt;_endRenderingDispatchBarrier.get()&lt;&lt;std::endl;&lt;br&gt;&lt;br&gt;   &nbsp;//&nbsp;wait&nbsp;till&nbsp;the&nbsp;rendering&nbsp;dispatch&nbsp;is&nbsp;done.&lt;br&gt;   &nbsp;if&nbsp;(_endRenderingDispatchBarrier.valid())&nbsp;_endRenderingDispatchBarrier-&gt;block();&lt;br&gt;&lt;br&gt;   &nbsp;//&nbsp;wait&nbsp;till&nbsp;the&nbsp;dynamic&nbsp;draw&nbsp;is&nbsp;complete.&lt;br&gt;   &nbsp;if&nbsp;(_endDynamicDrawBlock.valid())&nbsp;&lt;br&gt;     &nbsp;{&lt;br&gt;       &nbsp;//&nbsp;osg::Timer_t&nbsp;startTick&nbsp;=&nbsp;osg::Timer::instance()-&gt;tick();&lt;br&gt;       &nbsp;_endDynamicDrawBlock-&gt;block();&lt;br&gt;       &nbsp;//&nbsp;osg::notify(osg::NOTICE)&lt;&lt;&quot;Time&nbsp;waiting&nbsp;&quot;&lt;&lt;osg::Timer::instance()-&gt;delta_m(startTick,&nbsp;osg::Timer::instance()-&gt;tick())&lt;&lt;std::endl;;&lt;br&gt;     &nbsp;}&lt;br&gt;   &nbsp;&lt;br&gt;   &nbsp;if&nbsp;(_releaseContextAtEndOfFrameHint&nbsp;&amp;&amp;&nbsp;doneMakeCurrentInThisThread)&lt;br&gt;     &nbsp;{&lt;br&gt;       &nbsp;//osg::notify(osg::NOTICE)&lt;&lt;&quot;Doing&nbsp;release&nbsp;context&quot;&lt;&lt;std::endl;&lt;br&gt;       &nbsp;releaseContext();&lt;br&gt;     &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;void&nbsp;asyncRTTViewerConstructorInit(){&lt;br&gt;   &nbsp;offScreenNodes&nbsp;=&nbsp;new&nbsp;osg::Group();&lt;br&gt; &nbsp;}&lt;br&gt;       &nbsp;&lt;br&gt; &nbsp;osg::ref_ptr&lt;osg::Group&gt;&nbsp;offScreenNodes;&lt;br&gt;};&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;struct&nbsp;MyCameraPostDrawCallback&nbsp;:&nbsp;public&nbsp;osg::Camera::DrawCallback&lt;br&gt;{&lt;br&gt; &nbsp;MyCameraPostDrawCallback(osg::Image*&nbsp;image):&lt;br&gt;   &nbsp;_image(image)&lt;br&gt; &nbsp;{&lt;br&gt; &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;virtual&nbsp;void&nbsp;operator&nbsp;()&nbsp;(osg::RenderInfo&amp;&nbsp;renderInfo)&nbsp;const&lt;br&gt; &nbsp;{&lt;br&gt;   &nbsp;if&nbsp;(_image&nbsp;&amp;&amp;&nbsp;_image-&gt;getPixelFormat()==GL_RGBA&nbsp;&amp;&amp;&nbsp;_image-&gt;getDataType()==GL_UNSIGNED_BYTE)&lt;br&gt;     &nbsp;{&lt;br&gt;       &nbsp;printf(&quot;hello&nbsp;from&nbsp;image&nbsp;processing\n&quot;);&lt;br&gt;       &nbsp;//&nbsp;we&#39;ll&nbsp;pick&nbsp;out&nbsp;the&nbsp;center&nbsp;1/2&nbsp;of&nbsp;the&nbsp;whole&nbsp;image,&lt;br&gt;       &nbsp;int&nbsp;column_start&nbsp;=&nbsp;_image-&gt;s()/4;&lt;br&gt;       &nbsp;int&nbsp;column_end&nbsp;=&nbsp;3*column_start;&lt;br&gt;           &nbsp;&lt;br&gt;       &nbsp;int&nbsp;row_start&nbsp;=&nbsp;_image-&gt;t()/4;&lt;br&gt;       &nbsp;int&nbsp;row_end&nbsp;=&nbsp;3*row_start;&lt;br&gt;           &nbsp;&lt;br&gt;       &nbsp;//&nbsp;and&nbsp;then&nbsp;invert&nbsp;these&nbsp;pixels&lt;br&gt;       &nbsp;for(int&nbsp;r=row_start;&nbsp;r&lt;row_end;&nbsp;++r)&lt;br&gt;         &nbsp;{&lt;br&gt;           &nbsp;unsigned&nbsp;char*&nbsp;data&nbsp;=&nbsp;_image-&gt;data(column_start,&nbsp;r);&lt;br&gt;           &nbsp;for(int&nbsp;c=column_start;&nbsp;c&lt;column_end;&nbsp;++c)&lt;br&gt;             &nbsp;{&lt;br&gt;               &nbsp;(*data)&nbsp;=&nbsp;255-(*data);&nbsp;++data;&lt;br&gt;               &nbsp;(*data)&nbsp;=&nbsp;255-(*data);&nbsp;++data;&lt;br&gt;               &nbsp;(*data)&nbsp;=&nbsp;255-(*data);&nbsp;++data;&lt;br&gt;               &nbsp;(*data)&nbsp;=&nbsp;255;&nbsp;++data;&lt;br&gt;             &nbsp;}&lt;br&gt;         &nbsp;}&lt;br&gt;&lt;br&gt;       &nbsp;//&nbsp;dirty&nbsp;the&nbsp;image&nbsp;(increments&nbsp;the&nbsp;modified&nbsp;count)&nbsp;so&nbsp;that&nbsp;any&nbsp;textures&lt;br&gt;       &nbsp;//&nbsp;using&nbsp;the&nbsp;image&nbsp;can&nbsp;be&nbsp;informed&nbsp;that&nbsp;they&nbsp;need&nbsp;to&nbsp;update.&lt;br&gt;       &nbsp;_image-&gt;dirty();&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp;if&nbsp;(osgDB::writeImageFile(*_image,&nbsp;std::string(&quot;C:\\image.jpg&quot;)))&lt;br&gt;   &nbsp;   &nbsp;{&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;std::cout&nbsp;&lt;&lt;&nbsp;R&quot;(Saved&nbsp;screen&nbsp;image&nbsp;to&nbsp;`C:\image.jpg`)&quot;&nbsp;&lt;&lt;&nbsp;std::endl;&lt;br&gt;   &nbsp;   &nbsp;}&lt;br&gt;&lt;br&gt;     &nbsp;}&lt;br&gt;      &nbsp;&lt;br&gt; &nbsp;}  &nbsp;&lt;br&gt;&lt;br&gt; &nbsp;virtual&nbsp;void&nbsp;operator&nbsp;()&nbsp;(const&nbsp;osg::Camera&amp;&nbsp;/*camera*/)&nbsp;const&lt;br&gt; &nbsp;{&lt;br&gt;   &nbsp; &nbsp;if&nbsp;(_image&nbsp;&amp;&amp;&nbsp;_image-&gt;getPixelFormat()&nbsp;==&nbsp;GL_RGBA&nbsp;&amp;&amp;&nbsp;_image-&gt;getDataType()&nbsp;==&nbsp;GL_UNSIGNED_BYTE)&lt;br&gt;   &nbsp; &nbsp;{&lt;br&gt;   &nbsp;   &nbsp; &nbsp;printf(&quot;hello&nbsp;from&nbsp;image&nbsp;processing\n&quot;);&lt;br&gt;   &nbsp;   &nbsp; &nbsp;//&nbsp;we&#39;ll&nbsp;pick&nbsp;out&nbsp;the&nbsp;center&nbsp;1/2&nbsp;of&nbsp;the&nbsp;whole&nbsp;image,&lt;br&gt;   &nbsp;   &nbsp; &nbsp;int&nbsp;column_start&nbsp;=&nbsp;_image-&gt;s()&nbsp;/&nbsp;4;&lt;br&gt;   &nbsp;   &nbsp; &nbsp;int&nbsp;column_end&nbsp;=&nbsp;3&nbsp;*&nbsp;column_start;&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp; &nbsp;int&nbsp;row_start&nbsp;=&nbsp;_image-&gt;t()&nbsp;/&nbsp;4;&lt;br&gt;   &nbsp;   &nbsp; &nbsp;int&nbsp;row_end&nbsp;=&nbsp;3&nbsp;*&nbsp;row_start;&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp; &nbsp;//&nbsp;and&nbsp;then&nbsp;invert&nbsp;these&nbsp;pixels&lt;br&gt;   &nbsp;   &nbsp; &nbsp;for&nbsp;(int&nbsp;r&nbsp;=&nbsp;row_start;&nbsp;r&nbsp;&lt;&nbsp;row_end;&nbsp;++r)&lt;br&gt;   &nbsp;   &nbsp; &nbsp;{&lt;br&gt;   &nbsp;   &nbsp;   &nbsp; &nbsp;unsigned&nbsp;char*&nbsp;data&nbsp;=&nbsp;_image-&gt;data(column_start,&nbsp;r);&lt;br&gt;   &nbsp;   &nbsp;   &nbsp; &nbsp;for&nbsp;(int&nbsp;c&nbsp;=&nbsp;column_start;&nbsp;c&nbsp;&lt;&nbsp;column_end;&nbsp;++c)&lt;br&gt;   &nbsp;   &nbsp;   &nbsp; &nbsp;{&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;   &nbsp; &nbsp;(*data)&nbsp;=&nbsp;255&nbsp;-&nbsp;(*data);&nbsp;++data;&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;   &nbsp; &nbsp;(*data)&nbsp;=&nbsp;255&nbsp;-&nbsp;(*data);&nbsp;++data;&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;   &nbsp; &nbsp;(*data)&nbsp;=&nbsp;255&nbsp;-&nbsp;(*data);&nbsp;++data;&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;   &nbsp; &nbsp;(*data)&nbsp;=&nbsp;255;&nbsp;++data;&lt;br&gt;   &nbsp;   &nbsp;   &nbsp; &nbsp;}&lt;br&gt;   &nbsp;   &nbsp; &nbsp;}&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp; &nbsp;//&nbsp;dirty&nbsp;the&nbsp;image&nbsp;(increments&nbsp;the&nbsp;modified&nbsp;count)&nbsp;so&nbsp;that&nbsp;any&nbsp;textures&lt;br&gt;   &nbsp;   &nbsp; &nbsp;//&nbsp;using&nbsp;the&nbsp;image&nbsp;can&nbsp;be&nbsp;informed&nbsp;that&nbsp;they&nbsp;need&nbsp;to&nbsp;update.&lt;br&gt;   &nbsp;   &nbsp; &nbsp;_image-&gt;dirty();&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp; &nbsp;if&nbsp;(osgDB::writeImageFile(*_image,&nbsp;std::string(&quot;C:\\image.jpg&quot;)))&lt;br&gt;   &nbsp;   &nbsp; &nbsp;{&lt;br&gt;   &nbsp;   &nbsp;   &nbsp; &nbsp;std::cout&nbsp;&lt;&lt;&nbsp;R&quot;(Saved&nbsp;screen&nbsp;image&nbsp;to&nbsp;`C:\image.jpg`)&quot;&nbsp;&lt;&lt;&nbsp;std::endl;&lt;br&gt;   &nbsp;   &nbsp; &nbsp;}&lt;br&gt;   &nbsp; &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;osg::Image*&nbsp;_image;&lt;br&gt;};&lt;br&gt;&lt;br&gt;&lt;br&gt;int&nbsp;main222()&lt;br&gt;{&lt;br&gt;&lt;br&gt; &nbsp;bool&nbsp;useImage=true;&lt;br&gt;&lt;br&gt;   &nbsp;//   &nbsp;osgViewer::Viewer&nbsp;viewer(arguments);&lt;br&gt; &nbsp;AsyncRTTViewer&nbsp;viewer;&lt;br&gt; &nbsp;viewer.setThreadingModel(osgViewer::Viewer::SingleThreaded);&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;set&nbsp;up&nbsp;the&nbsp;camera&nbsp;manipulators.&lt;br&gt; &nbsp;{&lt;br&gt;   &nbsp;osg::ref_ptr&lt;osgGA::KeySwitchMatrixManipulator&gt;&nbsp;keyswitchManipulator&nbsp;=&nbsp;new&nbsp;osgGA::KeySwitchMatrixManipulator;&lt;br&gt;&lt;br&gt;   &nbsp;keyswitchManipulator-&gt;addMatrixManipulator(&nbsp;&#39;1&#39;,&nbsp;&quot;Trackball&quot;,&nbsp;new&nbsp;osgGA::TrackballManipulator()&nbsp;);&lt;br&gt;   &nbsp;keyswitchManipulator-&gt;addMatrixManipulator(&nbsp;&#39;2&#39;,&nbsp;&quot;Flight&quot;,&nbsp;new&nbsp;osgGA::FlightManipulator()&nbsp;);&lt;br&gt;   &nbsp;keyswitchManipulator-&gt;addMatrixManipulator(&nbsp;&#39;3&#39;,&nbsp;&quot;Drive&quot;,&nbsp;new&nbsp;osgGA::DriveManipulator()&nbsp;);&lt;br&gt;   &nbsp;viewer.setCameraManipulator(&nbsp;keyswitchManipulator.get()&nbsp;);&lt;br&gt; &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;add&nbsp;the&nbsp;state&nbsp;manipulator&lt;br&gt; &nbsp;viewer.addEventHandler(&nbsp;new&nbsp;osgGA::StateSetManipulator(viewer.getCamera()-&gt;getOrCreateStateSet())&nbsp;);   &nbsp;&lt;br&gt; &nbsp;viewer.addEventHandler(new&nbsp;osgViewer::ThreadingHandler);&lt;br&gt; &nbsp;viewer.addEventHandler(new&nbsp;osgViewer::WindowSizeHandler);&lt;br&gt; &nbsp;viewer.addEventHandler(new&nbsp;osgViewer::StatsHandler);&lt;br&gt; &nbsp;//viewer.addEventHandler(new&nbsp;osgViewer::HelpHandler(arguments.getApplicationUsage()));&lt;br&gt; &nbsp;viewer.addEventHandler(new&nbsp;osgViewer::RecordCameraPathHandler);&lt;br&gt; &nbsp;viewer.addEventHandler(new&nbsp;osgViewer::LODScaleHandler);   &nbsp;&lt;br&gt; &nbsp;viewer.realize();   &nbsp;&lt;br&gt;&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;load&nbsp;the&nbsp;data&lt;br&gt; &nbsp;osg::ref_ptr&lt;osg::Node&gt;&nbsp;loadedModel&nbsp;=&nbsp;osgDB::readNodeFile(std::string(&quot;C:\\cow.osg&quot;));&lt;br&gt; &nbsp;if&nbsp;(!loadedModel)&nbsp;&lt;br&gt;   &nbsp;{&lt;br&gt;     &nbsp;//std::cout&nbsp;&lt;&lt;&nbsp;arguments.getApplicationName()&nbsp;&lt;&lt;&quot;:&nbsp;No&nbsp;data&nbsp;loaded&quot;&nbsp;&lt;&lt;&nbsp;std::endl;&lt;br&gt;     &nbsp;return&nbsp;1;&lt;br&gt;   &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;we&nbsp;have&nbsp;a&nbsp;root&nbsp;object&nbsp;that&nbsp;contains&nbsp;a&nbsp;scene&nbsp;and&nbsp;some&nbsp;overlayed&nbsp;textures&nbsp;to&nbsp;show&lt;br&gt; &nbsp;//&nbsp;the&nbsp;content&nbsp;if&nbsp;a&nbsp;independently&nbsp;rendered&nbsp;texture&lt;br&gt; &nbsp;osg::Group*&nbsp;root&nbsp;=&nbsp;new&nbsp;osg::Group();&lt;br&gt; &nbsp;osg::Group*&nbsp;scene&nbsp;=&nbsp;new&nbsp;osg::Group();&lt;br&gt; &nbsp;root-&gt;addChild(scene);&lt;br&gt; &nbsp;scene-&gt;addChild(loadedModel.get());&lt;br&gt; &nbsp;//&nbsp;any&nbsp;option&nbsp;left&nbsp;unread&nbsp;are&nbsp;converted&nbsp;into&nbsp;errors&nbsp;to&nbsp;write&nbsp;out&nbsp;later.&lt;br&gt; &nbsp;//arguments.reportRemainingOptionsAsUnrecognized();&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;optimize&nbsp;the&nbsp;scene&nbsp;graph,&nbsp;remove&nbsp;redundant&nbsp;nodes&nbsp;and&nbsp;state&nbsp;etc.&lt;br&gt; &nbsp;osgUtil::Optimizer&nbsp;optimizer;&lt;br&gt; &nbsp;optimizer.optimize(loadedModel.get());&lt;br&gt;&lt;br&gt; &nbsp;viewer.setSceneData(root);   &nbsp;&lt;br&gt;   &nbsp;&lt;br&gt; &nbsp;//&nbsp;Now&nbsp;we&nbsp;create&nbsp;a&nbsp;normal&nbsp;Render&nbsp;to&nbsp;Texture&nbsp;camera&nbsp;&lt;br&gt; &nbsp;//&nbsp;Create&nbsp;the&nbsp;texture&nbsp;to&nbsp;render&nbsp;to&lt;br&gt; &nbsp;osg::Texture2D*&nbsp;texture&nbsp;=&nbsp;new&nbsp;osg::Texture2D;&lt;br&gt; &nbsp;texture-&gt;setTextureSize(256,&nbsp;256);&lt;br&gt; &nbsp;texture-&gt;setInternalFormat(GL_RGBA);&lt;br&gt; &nbsp;texture-&gt;setFilter(osg::Texture2D::MIN_FILTER,osg::Texture2D::LINEAR);&lt;br&gt; &nbsp;texture-&gt;setFilter(osg::Texture2D::MAG_FILTER,osg::Texture2D::LINEAR);&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;set&nbsp;up&nbsp;the&nbsp;render&nbsp;to&nbsp;texture&nbsp;camera.&lt;br&gt; &nbsp;osg::Camera*&nbsp;cam&nbsp;=&nbsp;new&nbsp;osg::Camera;&lt;br&gt; &nbsp;cam-&gt;setClearMask(GL_COLOR_BUFFER_BIT&nbsp;|&nbsp;GL_DEPTH_BUFFER_BIT);&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;set&nbsp;up&nbsp;projection.&lt;br&gt; &nbsp;cam-&gt;setProjectionMatrixAsPerspective(30,&nbsp;1,0.1,30);   &nbsp;&lt;br&gt; &nbsp;//&nbsp;set&nbsp;view&lt;br&gt; &nbsp;cam-&gt;setReferenceFrame(osg::Transform::ABSOLUTE_RF);&lt;br&gt; &nbsp;cam-&gt;setViewport(0,&nbsp;0,&nbsp;256,&nbsp;256);&lt;br&gt; &nbsp;//&nbsp;Frame&nbsp;buffer&nbsp;objects&nbsp;are&nbsp;the&nbsp;best&nbsp;option&lt;br&gt; &nbsp;cam-&gt;setRenderTargetImplementation(osg::Camera::PIXEL_BUFFER_RTT);&lt;br&gt; &nbsp;//&nbsp;We&nbsp;need&nbsp;to&nbsp;render&nbsp;to&nbsp;the&nbsp;texture&nbsp;BEFORE&nbsp;we&nbsp;render&nbsp;to&nbsp;the&nbsp;screen&lt;br&gt; &nbsp;cam-&gt;setRenderOrder(osg::Camera::PRE_RENDER);   &nbsp;&lt;br&gt;&lt;br&gt; &nbsp;osg::Image*&nbsp;image&nbsp;=&nbsp;new&nbsp;osg::Image;&lt;br&gt; &nbsp;if(useImage){&lt;br&gt;   &nbsp;image-&gt;allocateImage(256,&nbsp;256,&nbsp;1,&nbsp;GL_RGBA,&nbsp;GL_UNSIGNED_BYTE);&lt;br&gt;   &nbsp;//image-&gt;allocateImage(tex_width,&nbsp;tex_height,&nbsp;1,&nbsp;GL_RGBA,&nbsp;GL_FLOAT);&lt;br&gt;   &nbsp;//&nbsp;attach&nbsp;the&nbsp;image&nbsp;so&nbsp;its&nbsp;copied&nbsp;on&nbsp;each&nbsp;frame.&lt;br&gt;   &nbsp;cam-&gt;attach(osg::Camera::COLOR_BUFFER,&nbsp;image);&lt;br&gt;   &nbsp;cam-&gt;setPostDrawCallback(new&nbsp;MyCameraPostDrawCallback(image));&lt;br&gt;   &nbsp;texture-&gt;setImage(0,&nbsp;image);&lt;br&gt; &nbsp;}else{&lt;br&gt;   &nbsp;//&nbsp;The&nbsp;camera&nbsp;will&nbsp;render&nbsp;into&nbsp;the&nbsp;texture&nbsp;that&nbsp;we&nbsp;created&nbsp;earlier&lt;br&gt;   &nbsp;cam-&gt;attach(osg::Camera::COLOR_BUFFER,&nbsp;texture);&lt;br&gt; &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;Add&nbsp;world&nbsp;to&nbsp;be&nbsp;drawn&nbsp;to&nbsp;the&nbsp;texture&lt;br&gt; &nbsp;cam-&gt;addChild(loadedModel.get());&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;now&nbsp;we&nbsp;add&nbsp;the&nbsp;RTT&nbsp;camera&nbsp;to&nbsp;our&nbsp;custom&nbsp;viewer&lt;br&gt; &nbsp;viewer.addOffScreenRTTNode(cam);&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;set&nbsp;up&nbsp;the&nbsp;place&nbsp;where&nbsp;the&nbsp;content&nbsp;of&nbsp;the&nbsp;texture&nbsp;is&nbsp;seen&nbsp;in&nbsp;the&nbsp;normal&nbsp;scene&lt;br&gt; &nbsp;osg::ref_ptr&lt;osg::Geometry&gt;&nbsp;screenQuad;&lt;br&gt; &nbsp;screenQuad&nbsp;=&nbsp;osg::createTexturedQuadGeometry(osg::Vec3(),&lt;br&gt;                                              &nbsp;osg::Vec3(256,&nbsp;0.0,&nbsp;0.0),&lt;br&gt;                                              &nbsp;osg::Vec3(0.0,&nbsp;256,&nbsp;0.0));&lt;br&gt; &nbsp;osg::ref_ptr&lt;osg::Geode&gt;&nbsp;quadGeode&nbsp;=&nbsp;new&nbsp;osg::Geode;&lt;br&gt; &nbsp;quadGeode-&gt;addDrawable(screenQuad.get());&lt;br&gt; &nbsp;osg::StateSet&nbsp;*quadState&nbsp;=&nbsp;quadGeode-&gt;getOrCreateStateSet();&lt;br&gt; &nbsp;quadState-&gt;setMode(GL_LIGHTING,osg::StateAttribute::OFF);&lt;br&gt; &nbsp;quadState-&gt;setTextureAttributeAndModes(0,&nbsp;texture,&nbsp;osg::StateAttribute::ON);   &nbsp;&lt;br&gt; &nbsp;osg::ref_ptr&lt;osg::Camera&gt;&nbsp;orthoCamera&nbsp;=&nbsp;new&nbsp;osg::Camera;&lt;br&gt; &nbsp;//&nbsp;We&nbsp;don&#39;t&nbsp;want&nbsp;to&nbsp;apply&nbsp;perspective,&nbsp;just&nbsp;overlay&nbsp;using&nbsp;orthographic&lt;br&gt; &nbsp;orthoCamera-&gt;setProjectionMatrix(osg::Matrix::ortho2D(0,&nbsp;256,&nbsp;0,&nbsp;256));   &nbsp;&lt;br&gt; &nbsp;orthoCamera-&gt;setReferenceFrame(osg::Transform::ABSOLUTE_RF);&lt;br&gt; &nbsp;orthoCamera-&gt;setViewMatrix(osg::Matrix::identity());&lt;br&gt;       &nbsp;&lt;br&gt; &nbsp;orthoCamera-&gt;setViewport(0,&nbsp;0,&nbsp;256,256);     &nbsp;&lt;br&gt; &nbsp;orthoCamera-&gt;setRenderOrder(osg::Camera::POST_RENDER);&lt;br&gt;&lt;br&gt; &nbsp;//osg::Image*&nbsp;image&nbsp;=&nbsp;new&nbsp;osg::Image;&lt;br&gt; &nbsp;//image-&gt;allocateImage(256,&nbsp;256,&nbsp;1,&nbsp;GL_RGBA,&nbsp;GL_UNSIGNED_BYTE);&lt;br&gt; &nbsp;//image-&gt;allocateImage(tex_width,&nbsp;tex_height,&nbsp;1,&nbsp;GL_RGBA,&nbsp;GL_FLOAT);&lt;br&gt; &nbsp;//&nbsp;attach&nbsp;the&nbsp;image&nbsp;so&nbsp;its&nbsp;copied&nbsp;on&nbsp;each&nbsp;frame.&lt;br&gt; &nbsp;//orthoCamera-&gt;attach(osg::Camera::COLOR_BUFFER,&nbsp;image);&lt;br&gt; &nbsp;//orthoCamera-&gt;setPostDrawCallback(new&nbsp;MyCameraPostDrawCallback(image));&lt;br&gt;&lt;br&gt; &nbsp;orthoCamera-&gt;addChild(quadGeode.get());&lt;br&gt; &nbsp;//&nbsp;and&nbsp;add&nbsp;it&nbsp;to&nbsp;the&nbsp;root&nbsp;note&lt;br&gt; &nbsp;root-&gt;addChild(orthoCamera.get());   &nbsp;&lt;br&gt;&lt;br&gt; &lt;br&gt; &nbsp;int&nbsp;frame_count=0; &nbsp;&lt;br&gt; &nbsp;const&nbsp;int&nbsp;swap_every=200;&nbsp;//&nbsp;the&nbsp;texture&nbsp;rendering&nbsp;occurs&nbsp;only&nbsp;every&nbsp;200th&nbsp;frame&lt;br&gt; &nbsp;bool&nbsp;swap=true;&lt;br&gt; &nbsp;while(!viewer.done())&lt;br&gt;   &nbsp;{       &nbsp;&lt;br&gt;     &nbsp;if&nbsp;(swap&nbsp;&amp;&amp;&nbsp;0&nbsp;==&nbsp;(frame_count&nbsp;%&nbsp;swap_every))&lt;br&gt;   &nbsp;   &nbsp;{&lt;br&gt;       &nbsp;osg::Vec3&nbsp;eye;&nbsp;osg::Vec3&nbsp;center;&nbsp;osg::Vec3&nbsp;up;&nbsp;&lt;br&gt;       &nbsp;viewer.getCamera()-&gt;getViewMatrixAsLookAt(eye,center,up);&lt;br&gt;       &nbsp;//&nbsp;simply&nbsp;turn&nbsp;the&nbsp;up&nbsp;vector&nbsp;around&lt;br&gt;       &nbsp;cam-&gt;setViewMatrixAsLookAt(eye,&nbsp;center,&nbsp;-up);          &nbsp;&lt;br&gt;       &nbsp;//&nbsp;do&nbsp;the&nbsp;offscreen&nbsp;rendering&lt;br&gt;       &nbsp;viewer.renderOffScreen();&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp;//viewer.frame();&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp;image-&gt;readPixels(0,&nbsp;0,&nbsp;256,&nbsp;256,&nbsp;GL_RGBA,&nbsp;GL_UNSIGNED_BYTE);&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp;int&nbsp;column_start&nbsp;=&nbsp;image-&gt;s()&nbsp;/&nbsp;4;&lt;br&gt;   &nbsp;   &nbsp;int&nbsp;column_end&nbsp;=&nbsp;3&nbsp;*&nbsp;column_start;&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp;int&nbsp;row_start&nbsp;=&nbsp;image-&gt;t()&nbsp;/&nbsp;4;&lt;br&gt;   &nbsp;   &nbsp;int&nbsp;row_end&nbsp;=&nbsp;3&nbsp;*&nbsp;row_start;&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp;//&nbsp;and&nbsp;then&nbsp;invert&nbsp;these&nbsp;pixels&lt;br&gt;   &nbsp;   &nbsp;for&nbsp;(int&nbsp;r&nbsp;=&nbsp;row_start;&nbsp;r&nbsp;&lt;&nbsp;row_end;&nbsp;++r)&lt;br&gt;   &nbsp;   &nbsp;{&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;unsigned&nbsp;char*&nbsp;data&nbsp;=&nbsp;image-&gt;data(column_start,&nbsp;r);&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;for&nbsp;(int&nbsp;c&nbsp;=&nbsp;column_start;&nbsp;c&nbsp;&lt;&nbsp;column_end;&nbsp;++c)&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;{&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;   &nbsp;(*data)&nbsp;=&nbsp;255&nbsp;-&nbsp;(*data);&nbsp;++data;&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;   &nbsp;(*data)&nbsp;=&nbsp;255&nbsp;-&nbsp;(*data);&nbsp;++data;&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;   &nbsp;(*data)&nbsp;=&nbsp;255&nbsp;-&nbsp;(*data);&nbsp;++data;&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;   &nbsp;(*data)&nbsp;=&nbsp;255;&nbsp;++data;&lt;br&gt;   &nbsp;   &nbsp;   &nbsp;}&lt;br&gt;   &nbsp;   &nbsp;}&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp;////&nbsp;dirty&nbsp;the&nbsp;image&nbsp;(increments&nbsp;the&nbsp;modified&nbsp;count)&nbsp;so&nbsp;that&nbsp;any&nbsp;textures&lt;br&gt;   &nbsp;   &nbsp;////&nbsp;using&nbsp;the&nbsp;image&nbsp;can&nbsp;be&nbsp;informed&nbsp;that&nbsp;they&nbsp;need&nbsp;to&nbsp;update.&lt;br&gt;   &nbsp;   &nbsp;image-&gt;dirty();&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp;//if&nbsp;(osgDB::writeImageFile(*image,&nbsp;std::string(&quot;C:\\image.jpg&quot;)))&lt;br&gt;   &nbsp;   &nbsp;//{&lt;br&gt;   &nbsp;   &nbsp;//   &nbsp;std::cout&nbsp;&lt;&lt;&nbsp;R&quot;(Saved&nbsp;screen&nbsp;image&nbsp;to&nbsp;`C:\image.jpg`)&quot;&nbsp;&lt;&lt;&nbsp;std::endl;&lt;br&gt;   &nbsp;   &nbsp;//}&lt;br&gt;&lt;br&gt;     &nbsp;}&lt;br&gt;   &nbsp;else&lt;br&gt;   &nbsp;{&lt;br&gt;   &nbsp;   &nbsp;viewer.frame();&lt;br&gt;   &nbsp;}&lt;br&gt;     &nbsp;&lt;br&gt;     &nbsp;frame_count++;     &nbsp;&lt;br&gt;   &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;return&nbsp;0;&lt;br&gt;}&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;The&nbsp;way&nbsp;I&nbsp;am&nbsp;using&nbsp;this&nbsp;class&nbsp;is:&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt; &nbsp;bool&nbsp;useImage=true;&lt;br&gt;&lt;br&gt;   &nbsp;//   &nbsp;osgViewer::Viewer&nbsp;viewer(arguments);&lt;br&gt; &nbsp;AsyncRTTViewer&nbsp;viewer;&lt;br&gt; &nbsp;viewer.setThreadingModel(osgViewer::Viewer::SingleThreaded);&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;set&nbsp;up&nbsp;the&nbsp;camera&nbsp;manipulators.&lt;br&gt; &nbsp;{&lt;br&gt;   &nbsp;osg::ref_ptr&lt;osgGA::KeySwitchMatrixManipulator&gt;&nbsp;keyswitchManipulator&nbsp;=&nbsp;new&nbsp;osgGA::KeySwitchMatrixManipulator;&lt;br&gt;&lt;br&gt;   &nbsp;keyswitchManipulator-&gt;addMatrixManipulator(&nbsp;&#39;1&#39;,&nbsp;&quot;Trackball&quot;,&nbsp;new&nbsp;osgGA::TrackballManipulator()&nbsp;);&lt;br&gt;   &nbsp;keyswitchManipulator-&gt;addMatrixManipulator(&nbsp;&#39;2&#39;,&nbsp;&quot;Flight&quot;,&nbsp;new&nbsp;osgGA::FlightManipulator()&nbsp;);&lt;br&gt;   &nbsp;keyswitchManipulator-&gt;addMatrixManipulator(&nbsp;&#39;3&#39;,&nbsp;&quot;Drive&quot;,&nbsp;new&nbsp;osgGA::DriveManipulator()&nbsp;);&lt;br&gt;   &nbsp;viewer.setCameraManipulator(&nbsp;keyswitchManipulator.get()&nbsp;);&lt;br&gt; &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;add&nbsp;the&nbsp;state&nbsp;manipulator&lt;br&gt; &nbsp;viewer.addEventHandler(&nbsp;new&nbsp;osgGA::StateSetManipulator(viewer.getCamera()-&gt;getOrCreateStateSet())&nbsp;);   &nbsp;&lt;br&gt; &nbsp;viewer.addEventHandler(new&nbsp;osgViewer::ThreadingHandler);&lt;br&gt; &nbsp;viewer.addEventHandler(new&nbsp;osgViewer::WindowSizeHandler);&lt;br&gt; &nbsp;viewer.addEventHandler(new&nbsp;osgViewer::StatsHandler);&lt;br&gt; &nbsp;//viewer.addEventHandler(new&nbsp;osgViewer::HelpHandler(arguments.getApplicationUsage()));&lt;br&gt; &nbsp;viewer.addEventHandler(new&nbsp;osgViewer::RecordCameraPathHandler);&lt;br&gt; &nbsp;viewer.addEventHandler(new&nbsp;osgViewer::LODScaleHandler);   &nbsp;&lt;br&gt; &nbsp;viewer.realize();   &nbsp;&lt;br&gt;&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;load&nbsp;the&nbsp;data&lt;br&gt; &nbsp;osg::ref_ptr&lt;osg::Node&gt;&nbsp;loadedModel&nbsp;=&nbsp;osgDB::readNodeFile(std::string(&quot;C:\\cow.osg&quot;));&lt;br&gt; &nbsp;if&nbsp;(!loadedModel)&nbsp;&lt;br&gt;   &nbsp;{&lt;br&gt;     &nbsp;//std::cout&nbsp;&lt;&lt;&nbsp;arguments.getApplicationName()&nbsp;&lt;&lt;&quot;:&nbsp;No&nbsp;data&nbsp;loaded&quot;&nbsp;&lt;&lt;&nbsp;std::endl;&lt;br&gt;     &nbsp;return&nbsp;1;&lt;br&gt;   &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;we&nbsp;have&nbsp;a&nbsp;root&nbsp;object&nbsp;that&nbsp;contains&nbsp;a&nbsp;scene&nbsp;and&nbsp;some&nbsp;overlayed&nbsp;textures&nbsp;to&nbsp;show&lt;br&gt; &nbsp;//&nbsp;the&nbsp;content&nbsp;if&nbsp;a&nbsp;independently&nbsp;rendered&nbsp;texture&lt;br&gt; &nbsp;osg::Group*&nbsp;root&nbsp;=&nbsp;new&nbsp;osg::Group();&lt;br&gt; &nbsp;osg::Group*&nbsp;scene&nbsp;=&nbsp;new&nbsp;osg::Group();&lt;br&gt; &nbsp;root-&gt;addChild(scene);&lt;br&gt; &nbsp;scene-&gt;addChild(loadedModel.get());&lt;br&gt; &nbsp;//&nbsp;any&nbsp;option&nbsp;left&nbsp;unread&nbsp;are&nbsp;converted&nbsp;into&nbsp;errors&nbsp;to&nbsp;write&nbsp;out&nbsp;later.&lt;br&gt; &nbsp;//arguments.reportRemainingOptionsAsUnrecognized();&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;optimize&nbsp;the&nbsp;scene&nbsp;graph,&nbsp;remove&nbsp;redundant&nbsp;nodes&nbsp;and&nbsp;state&nbsp;etc.&lt;br&gt; &nbsp;osgUtil::Optimizer&nbsp;optimizer;&lt;br&gt; &nbsp;optimizer.optimize(loadedModel.get());&lt;br&gt;&lt;br&gt; &nbsp;viewer.setSceneData(root);   &nbsp;&lt;br&gt;   &nbsp;&lt;br&gt; &nbsp;//&nbsp;Now&nbsp;we&nbsp;create&nbsp;a&nbsp;normal&nbsp;Render&nbsp;to&nbsp;Texture&nbsp;camera&nbsp;&lt;br&gt; &nbsp;//&nbsp;Create&nbsp;the&nbsp;texture&nbsp;to&nbsp;render&nbsp;to&lt;br&gt; &nbsp;osg::Texture2D*&nbsp;texture&nbsp;=&nbsp;new&nbsp;osg::Texture2D;&lt;br&gt; &nbsp;texture-&gt;setTextureSize(256,&nbsp;256);&lt;br&gt; &nbsp;texture-&gt;setInternalFormat(GL_RGBA);&lt;br&gt; &nbsp;texture-&gt;setFilter(osg::Texture2D::MIN_FILTER,osg::Texture2D::LINEAR);&lt;br&gt; &nbsp;texture-&gt;setFilter(osg::Texture2D::MAG_FILTER,osg::Texture2D::LINEAR);&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;set&nbsp;up&nbsp;the&nbsp;render&nbsp;to&nbsp;texture&nbsp;camera.&lt;br&gt; &nbsp;osg::Camera*&nbsp;cam&nbsp;=&nbsp;new&nbsp;osg::Camera;&lt;br&gt; &nbsp;cam-&gt;setClearMask(GL_COLOR_BUFFER_BIT&nbsp;|&nbsp;GL_DEPTH_BUFFER_BIT);&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;set&nbsp;up&nbsp;projection.&lt;br&gt; &nbsp;cam-&gt;setProjectionMatrixAsPerspective(30,&nbsp;1,0.1,30);   &nbsp;&lt;br&gt; &nbsp;//&nbsp;set&nbsp;view&lt;br&gt; &nbsp;cam-&gt;setReferenceFrame(osg::Transform::ABSOLUTE_RF);&lt;br&gt; &nbsp;cam-&gt;setViewport(0,&nbsp;0,&nbsp;256,&nbsp;256);&lt;br&gt; &nbsp;//&nbsp;Frame&nbsp;buffer&nbsp;objects&nbsp;are&nbsp;the&nbsp;best&nbsp;option&lt;br&gt; &nbsp;cam-&gt;setRenderTargetImplementation(osg::Camera::PIXEL_BUFFER_RTT);&lt;br&gt; &nbsp;//&nbsp;We&nbsp;need&nbsp;to&nbsp;render&nbsp;to&nbsp;the&nbsp;texture&nbsp;BEFORE&nbsp;we&nbsp;render&nbsp;to&nbsp;the&nbsp;screen&lt;br&gt; &nbsp;cam-&gt;setRenderOrder(osg::Camera::PRE_RENDER);   &nbsp;&lt;br&gt;&lt;br&gt; &nbsp;osg::Image*&nbsp;image&nbsp;=&nbsp;new&nbsp;osg::Image;&lt;br&gt; &nbsp;if(useImage){&lt;br&gt;   &nbsp;image-&gt;allocateImage(256,&nbsp;256,&nbsp;1,&nbsp;GL_RGBA,&nbsp;GL_UNSIGNED_BYTE);&lt;br&gt;   &nbsp;//image-&gt;allocateImage(tex_width,&nbsp;tex_height,&nbsp;1,&nbsp;GL_RGBA,&nbsp;GL_FLOAT);&lt;br&gt;   &nbsp;//&nbsp;attach&nbsp;the&nbsp;image&nbsp;so&nbsp;its&nbsp;copied&nbsp;on&nbsp;each&nbsp;frame.&lt;br&gt;   &nbsp;cam-&gt;attach(osg::Camera::COLOR_BUFFER,&nbsp;image);&lt;br&gt;   &nbsp;cam-&gt;setPostDrawCallback(new&nbsp;MyCameraPostDrawCallback(image));&lt;br&gt;   &nbsp;texture-&gt;setImage(0,&nbsp;image);&lt;br&gt; &nbsp;}else{&lt;br&gt;   &nbsp;//&nbsp;The&nbsp;camera&nbsp;will&nbsp;render&nbsp;into&nbsp;the&nbsp;texture&nbsp;that&nbsp;we&nbsp;created&nbsp;earlier&lt;br&gt;   &nbsp;cam-&gt;attach(osg::Camera::COLOR_BUFFER,&nbsp;texture);&lt;br&gt; &nbsp;}&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;Add&nbsp;world&nbsp;to&nbsp;be&nbsp;drawn&nbsp;to&nbsp;the&nbsp;texture&lt;br&gt; &nbsp;cam-&gt;addChild(loadedModel.get());&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;now&nbsp;we&nbsp;add&nbsp;the&nbsp;RTT&nbsp;camera&nbsp;to&nbsp;our&nbsp;custom&nbsp;viewer&lt;br&gt; &nbsp;viewer.addOffScreenRTTNode(cam);&lt;br&gt;&lt;br&gt; &nbsp;//&nbsp;set&nbsp;up&nbsp;the&nbsp;place&nbsp;where&nbsp;the&nbsp;content&nbsp;of&nbsp;the&nbsp;texture&nbsp;is&nbsp;seen&nbsp;in&nbsp;the&nbsp;normal&nbsp;scene&lt;br&gt; &nbsp;osg::ref_ptr&lt;osg::Geometry&gt;&nbsp;screenQuad;&lt;br&gt; &nbsp;screenQuad&nbsp;=&nbsp;osg::createTexturedQuadGeometry(osg::Vec3(),&lt;br&gt;                                              &nbsp;osg::Vec3(256,&nbsp;0.0,&nbsp;0.0),&lt;br&gt;                                              &nbsp;osg::Vec3(0.0,&nbsp;256,&nbsp;0.0));&lt;br&gt; &nbsp;osg::ref_ptr&lt;osg::Geode&gt;&nbsp;quadGeode&nbsp;=&nbsp;new&nbsp;osg::Geode;&lt;br&gt; &nbsp;quadGeode-&gt;addDrawable(screenQuad.get());&lt;br&gt; &nbsp;osg::StateSet&nbsp;*quadState&nbsp;=&nbsp;quadGeode-&gt;getOrCreateStateSet();&lt;br&gt; &nbsp;quadState-&gt;setMode(GL_LIGHTING,osg::StateAttribute::OFF);&lt;br&gt; &nbsp;quadState-&gt;setTextureAttributeAndModes(0,&nbsp;texture,&nbsp;osg::StateAttribute::ON);   &nbsp;&lt;br&gt; &nbsp;osg::ref_ptr&lt;osg::Camera&gt;&nbsp;orthoCamera&nbsp;=&nbsp;new&nbsp;osg::Camera;&lt;br&gt; &nbsp;//&nbsp;We&nbsp;don&#39;t&nbsp;want&nbsp;to&nbsp;apply&nbsp;perspective,&nbsp;just&nbsp;overlay&nbsp;using&nbsp;orthographic&lt;br&gt; &nbsp;orthoCamera-&gt;setProjectionMatrix(osg::Matrix::ortho2D(0,&nbsp;256,&nbsp;0,&nbsp;256));   &nbsp;&lt;br&gt; &nbsp;orthoCamera-&gt;setReferenceFrame(osg::Transform::ABSOLUTE_RF);&lt;br&gt; &nbsp;orthoCamera-&gt;setViewMatrix(osg::Matrix::identity());&lt;br&gt;       &nbsp;&lt;br&gt; &nbsp;orthoCamera-&gt;setViewport(0,&nbsp;0,&nbsp;256,256);     &nbsp;&lt;br&gt; &nbsp;orthoCamera-&gt;setRenderOrder(osg::Camera::POST_RENDER);&lt;br&gt;&lt;br&gt; &nbsp;//osg::Image*&nbsp;image&nbsp;=&nbsp;new&nbsp;osg::Image;&lt;br&gt; &nbsp;//image-&gt;allocateImage(256,&nbsp;256,&nbsp;1,&nbsp;GL_RGBA,&nbsp;GL_UNSIGNED_BYTE);&lt;br&gt; &nbsp;//image-&gt;allocateImage(tex_width,&nbsp;tex_height,&nbsp;1,&nbsp;GL_RGBA,&nbsp;GL_FLOAT);&lt;br&gt; &nbsp;//&nbsp;attach&nbsp;the&nbsp;image&nbsp;so&nbsp;its&nbsp;copied&nbsp;on&nbsp;each&nbsp;frame.&lt;br&gt; &nbsp;//orthoCamera-&gt;attach(osg::Camera::COLOR_BUFFER,&nbsp;image);&lt;br&gt; &nbsp;//orthoCamera-&gt;setPostDrawCallback(new&nbsp;MyCameraPostDrawCallback(image));&lt;br&gt;&lt;br&gt; &nbsp;orthoCamera-&gt;addChild(quadGeode.get());&lt;br&gt; &nbsp;//&nbsp;and&nbsp;add&nbsp;it&nbsp;to&nbsp;the&nbsp;root&nbsp;note&lt;br&gt; &nbsp;root-&gt;addChild(orthoCamera.get());   &nbsp;&lt;br&gt;&lt;br&gt; &lt;br&gt; &nbsp;int&nbsp;frame_count=0; &nbsp;&lt;br&gt; &nbsp;const&nbsp;int&nbsp;swap_every=200;&nbsp;//&nbsp;the&nbsp;texture&nbsp;rendering&nbsp;occurs&nbsp;only&nbsp;every&nbsp;200th&nbsp;frame&lt;br&gt; &nbsp;bool&nbsp;swap=true;&lt;br&gt; &nbsp;while(!viewer.done())&lt;br&gt;   &nbsp;{       &nbsp;&lt;br&gt;     &nbsp;if&nbsp;(swap&nbsp;&amp;&amp;&nbsp;0&nbsp;==&nbsp;(frame_count&nbsp;%&nbsp;swap_every))&lt;br&gt;   &nbsp;   &nbsp;{&lt;br&gt;       &nbsp;osg::Vec3&nbsp;eye;&nbsp;osg::Vec3&nbsp;center;&nbsp;osg::Vec3&nbsp;up;&nbsp;&lt;br&gt;       &nbsp;viewer.getCamera()-&gt;getViewMatrixAsLookAt(eye,center,up);&lt;br&gt;       &nbsp;//&nbsp;simply&nbsp;turn&nbsp;the&nbsp;up&nbsp;vector&nbsp;around&lt;br&gt;       &nbsp;cam-&gt;setViewMatrixAsLookAt(eye,&nbsp;center,&nbsp;-up);          &nbsp;&lt;br&gt;       &nbsp;//&nbsp;do&nbsp;the&nbsp;offscreen&nbsp;rendering&lt;br&gt;       &nbsp;viewer.renderOffScreen();&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp;////&nbsp;dirty&nbsp;the&nbsp;image&nbsp;(increments&nbsp;the&nbsp;modified&nbsp;count)&nbsp;so&nbsp;that&nbsp;any&nbsp;textures&lt;br&gt;   &nbsp;   &nbsp;////&nbsp;using&nbsp;the&nbsp;image&nbsp;can&nbsp;be&nbsp;informed&nbsp;that&nbsp;they&nbsp;need&nbsp;to&nbsp;update.&lt;br&gt;   &nbsp;   &nbsp;image-&gt;dirty();&lt;br&gt;&lt;br&gt;   &nbsp;   &nbsp;//if&nbsp;(osgDB::writeImageFile(*image,&nbsp;std::string(&quot;C:\\image.jpg&quot;)))&lt;br&gt;   &nbsp;   &nbsp;//{&lt;br&gt;   &nbsp;   &nbsp;//   &nbsp;std::cout&nbsp;&lt;&lt;&nbsp;R&quot;(Saved&nbsp;screen&nbsp;image&nbsp;to&nbsp;`C:\image.jpg`)&quot;&nbsp;&lt;&lt;&nbsp;std::endl;&lt;br&gt;   &nbsp;   &nbsp;//}&lt;br&gt;&lt;br&gt;     &nbsp;}&lt;br&gt;   &nbsp;else&lt;br&gt;   &nbsp;{&lt;br&gt;   &nbsp;   &nbsp;viewer.frame();&lt;br&gt;   &nbsp;}&lt;br&gt;     &nbsp;&lt;br&gt;     &nbsp;frame_count++;     &nbsp;&lt;br&gt;   &nbsp;}&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;This&nbsp;code&nbsp;in&nbsp;no&nbsp;longer&nbsp;present&nbsp;in&nbsp;OSG&nbsp;3.4.0,&nbsp;so&nbsp;it&nbsp;must&nbsp;be&nbsp;older&nbsp;and&nbsp;may&nbsp;have&nbsp;worked&nbsp;with&nbsp;earlier&nbsp;versions&nbsp;of&nbsp;OSG?&nbsp;I&nbsp;am&nbsp;not&nbsp;sure....&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;The&nbsp;issue&nbsp;is&nbsp;that&nbsp;the&nbsp;image&nbsp;I&nbsp;need,&nbsp;that&nbsp;should&nbsp;be&nbsp;done&nbsp;in&nbsp;PRE_RENDER,&nbsp;so&nbsp;before&nbsp;the&nbsp;first&nbsp;frame,&nbsp;is&nbsp;not&nbsp;produced.&nbsp;And&nbsp;none&nbsp;of&nbsp;the&nbsp;sybsequent&nbsp;200&#39;th&nbsp;frame&nbsp;are&nbsp;not&nbsp;done&nbsp;either.&lt;/div&gt;&lt;div&gt;The&nbsp;call&nbsp;back&nbsp;installed&nbsp;here:&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;cam-&gt;setPostDrawCallback(new&nbsp;MyCameraPostDrawCallback(image));&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;is&nbsp;not&nbsp;invoked&nbsp;in&nbsp;MyCameraPostDrawCallback::operator&nbsp;()&nbsp;(osg::RenderInfo&amp;&nbsp;renderInfo)&nbsp;const&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Any&nbsp;idea&nbsp;why&nbsp;this&nbsp;callback&nbsp;is&nbsp;not&nbsp;called?&nbsp;I&nbsp;can&#39;t&nbsp;move&nbsp;on&nbsp;because&nbsp;of&nbsp;this&nbsp;issue.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;If&nbsp;I&nbsp;install&nbsp;it&nbsp;on&nbsp;the&nbsp;other&nbsp;camera&nbsp;on&nbsp;osg::Camera::POST_RENDER&nbsp;phase&nbsp;(orthoCamera)&nbsp;than&nbsp;it&nbsp;gets&nbsp;called,&nbsp;but&nbsp;this&nbsp;is&nbsp;not&nbsp;what&nbsp;I&nbsp;need&nbsp;as&nbsp;it&nbsp;creates&nbsp;a&nbsp;window...I&nbsp;must&nbsp;avoid&nbsp;that...&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Any&nbsp;help&nbsp;will&nbsp;be&nbsp;aprreciated.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Thank&nbsp;you,&lt;/div&gt;&lt;div&gt;Sorin.&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;<br>

</tt>
