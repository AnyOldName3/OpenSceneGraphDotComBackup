<tt>
&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;html&gt;&lt;head&gt;&lt;meta&nbsp;name=&quot;viewport&quot;&nbsp;content=&quot;width=device-width&quot;&nbsp;/&gt;&lt;meta&nbsp;http-equiv=&quot;Content-Type&quot;&nbsp;content=&quot;text/vnd.ui.insecure+html;charset=utf-8&quot;&nbsp;/&gt;&lt;/head&gt;&lt;body&nbsp;style=&quot;overflow-wrap:break-word;&nbsp;word-break:&nbsp;break-word;&quot;&gt;&lt;div&nbsp;class=&quot;mail_android_message&quot;&nbsp;style=&quot;line-height:&nbsp;1;&nbsp;padding:&nbsp;0.5em&quot;&gt;Hi.&nbsp;Sorry&nbsp;I&nbsp;don&#39;t&nbsp;on&nbsp;my&nbsp;computer&nbsp;right&nbsp;now,&nbsp;but&nbsp;it&nbsp;seems&nbsp;you&nbsp;are&nbsp;not&nbsp;providing&nbsp;vertex&nbsp;shaders.&nbsp;I&#39;m&nbsp;not&nbsp;sure,&nbsp;but&nbsp;that&nbsp;might&nbsp;cause&nbsp;trouble.&nbsp;I&#39;ll&nbsp;get&nbsp;back&nbsp;to&nbsp;the&nbsp;issue&nbsp;tommorow&nbsp;or&nbsp;on&nbsp;Monday.&nbsp;&lt;br&gt;<br>
&lt;br&gt;<br>
Cheers&lt;br&gt;<br>
Sebastian&lt;br&gt;<br>
--&nbsp;&lt;br&gt;<br>
Sent&nbsp;from&nbsp;my&nbsp;Android&nbsp;phone&nbsp;with&nbsp;GMX&nbsp;Mail.&nbsp;Please&nbsp;excuse&nbsp;my&nbsp;brevity.&lt;/div&gt;&lt;div&nbsp;class=&quot;mail_android_quote&quot;&nbsp;style=&quot;line-height:&nbsp;1;&nbsp;padding:&nbsp;0.3em&quot;&gt;On&nbsp;9/2/17,&nbsp;21:36&nbsp;antiro&nbsp;black&nbsp;&lt;antiro42@gmail.com&gt;&nbsp;wrote:&lt;blockquote&nbsp;class=&quot;gmail_quote&quot;&nbsp;style=&quot;margin:&nbsp;0.8ex&nbsp;0pt&nbsp;0pt&nbsp;0.8ex;&nbsp;border-left:&nbsp;1px&nbsp;solid&nbsp;rgb(204,&nbsp;204,&nbsp;204);&nbsp;padding-left:&nbsp;1ex;&quot;&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;Hi&nbsp;Sebastian,&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;I'm&nbsp;compiling&nbsp;under&nbsp;debian&nbsp;jessie&nbsp;64&nbsp;bits&nbsp;and&nbsp;am&nbsp;running&nbsp;a&nbsp;NVIDIA&nbsp;GTX&nbsp;970.&nbsp;The&nbsp;drivers&nbsp;have&nbsp;been&nbsp;updates&nbsp;recently&nbsp;and&nbsp;I&nbsp;am&nbsp;running&nbsp;version&nbsp;384.69&nbsp;now.&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;I&nbsp;included&nbsp;a&nbsp;compilable&nbsp;minimal&nbsp;example&nbsp;based&nbsp;on&nbsp;the&nbsp;osgmultiplerendertargets&nbsp;example.&nbsp;Without&nbsp;VertexAttributeAliasing&nbsp;it&nbsp;generates&nbsp;two&nbsp;texture&nbsp;using&nbsp;MRT,&nbsp;a&nbsp;red&nbsp;and&nbsp;a&nbsp;green&nbsp;one,&nbsp;it&nbsp;then&nbsp;combines&nbsp;these&nbsp;in&nbsp;a&nbsp;second&nbsp;pass&nbsp;to&nbsp;generate&nbsp;the&nbsp;final&nbsp;texture&nbsp;(yellow).&nbsp;(The&nbsp;red&nbsp;and&nbsp;green&nbsp;intermediate&nbsp;textures&nbsp;are&nbsp;shown&nbsp;in&nbsp;small&nbsp;quads&nbsp;to&nbsp;the&nbsp;side.)&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;When&nbsp;I&nbsp;enable&nbsp;the&nbsp;attribute&nbsp;aliasing&nbsp;(as&nbsp;in&nbsp;the&nbsp;included&nbsp;code),&nbsp;the&nbsp;two&nbsp;textures&nbsp;generated&nbsp;in&nbsp;the&nbsp;MRT&nbsp;pass&nbsp;turn&nbsp;into&nbsp;gradients,&nbsp;as&nbsp;if&nbsp;something&nbsp;has&nbsp;gone&nbsp;wrong&nbsp;with&nbsp;the&nbsp;mapping.&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;Screenshots:&lt;br&nbsp;/&gt;<br>
The&nbsp;expected&nbsp;result&nbsp;(which&nbsp;I&nbsp;get&nbsp;without&nbsp;attribute&nbsp;aliasing):&nbsp;&lt;a&nbsp;href=&quot;https://ibb.co/kHEogv&quot;&gt;https://ibb.co/kHEogv&lt;/a&gt;&lt;br&nbsp;/&gt;<br>
The&nbsp;result&nbsp;with&nbsp;aliasing:&nbsp;&lt;a&nbsp;href=&quot;https://ibb.co/d9cfuF&quot;&gt;https://ibb.co/d9cfuF&lt;/a&gt;&lt;br&nbsp;/&gt;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;Code:&lt;br&nbsp;/&gt;<br>
/*&nbsp;OpenSceneGraph&nbsp;example,&nbsp;osgmultiplerendertargets.&lt;br&nbsp;/&gt;<br>
*&lt;br&nbsp;/&gt;<br>
*&nbsp;Permission&nbsp;is&nbsp;hereby&nbsp;granted,&nbsp;free&nbsp;of&nbsp;charge,&nbsp;to&nbsp;any&nbsp;person&nbsp;obtaining&nbsp;a&nbsp;copy&lt;br&nbsp;/&gt;<br>
*&nbsp;of&nbsp;this&nbsp;software&nbsp;and&nbsp;associated&nbsp;documentation&nbsp;files&nbsp;(the&nbsp;&quot;Software&quot;),&nbsp;to&nbsp;deal&lt;br&nbsp;/&gt;<br>
*&nbsp;in&nbsp;the&nbsp;Software&nbsp;without&nbsp;restriction,&nbsp;including&nbsp;without&nbsp;limitation&nbsp;the&nbsp;rights&lt;br&nbsp;/&gt;<br>
*&nbsp;to&nbsp;use,&nbsp;copy,&nbsp;modify,&nbsp;merge,&nbsp;publish,&nbsp;distribute,&nbsp;sublicense,&nbsp;and/or&nbsp;sell&lt;br&nbsp;/&gt;<br>
*&nbsp;copies&nbsp;of&nbsp;the&nbsp;Software,&nbsp;and&nbsp;to&nbsp;permit&nbsp;persons&nbsp;to&nbsp;whom&nbsp;the&nbsp;Software&nbsp;is&lt;br&nbsp;/&gt;<br>
*&nbsp;furnished&nbsp;to&nbsp;do&nbsp;so,&nbsp;subject&nbsp;to&nbsp;the&nbsp;following&nbsp;conditions:&lt;br&nbsp;/&gt;<br>
*&lt;br&nbsp;/&gt;<br>
*&nbsp;THE&nbsp;SOFTWARE&nbsp;IS&nbsp;PROVIDED&nbsp;&quot;AS&nbsp;IS&quot;,&nbsp;WITHOUT&nbsp;WARRANTY&nbsp;OF&nbsp;ANY&nbsp;KIND,&nbsp;EXPRESS&nbsp;OR&lt;br&nbsp;/&gt;<br>
*&nbsp;IMPLIED,&nbsp;INCLUDING&nbsp;BUT&nbsp;NOT&nbsp;LIMITED&nbsp;TO&nbsp;THE&nbsp;WARRANTIES&nbsp;OF&nbsp;MERCHANTABILITY,&lt;br&nbsp;/&gt;<br>
*&nbsp;FITNESS&nbsp;FOR&nbsp;A&nbsp;PARTICULAR&nbsp;PURPOSE&nbsp;AND&nbsp;NONINFRINGEMENT.&nbsp;IN&nbsp;NO&nbsp;EVENT&nbsp;SHALL&nbsp;THE&lt;br&nbsp;/&gt;<br>
*&nbsp;AUTHORS&nbsp;OR&nbsp;COPYRIGHT&nbsp;HOLDERS&nbsp;BE&nbsp;LIABLE&nbsp;FOR&nbsp;ANY&nbsp;CLAIM,&nbsp;DAMAGES&nbsp;OR&nbsp;OTHER&lt;br&nbsp;/&gt;<br>
*&nbsp;LIABILITY,&nbsp;WHETHER&nbsp;IN&nbsp;AN&nbsp;ACTION&nbsp;OF&nbsp;CONTRACT,&nbsp;TORT&nbsp;OR&nbsp;OTHERWISE,&nbsp;ARISING&nbsp;FROM,&lt;br&nbsp;/&gt;<br>
*&nbsp;OUT&nbsp;OF&nbsp;OR&nbsp;IN&nbsp;CONNECTION&nbsp;WITH&nbsp;THE&nbsp;SOFTWARE&nbsp;OR&nbsp;THE&nbsp;USE&nbsp;OR&nbsp;OTHER&nbsp;DEALINGS&nbsp;IN&lt;br&nbsp;/&gt;<br>
*&nbsp;THE&nbsp;SOFTWARE.&lt;br&nbsp;/&gt;<br>
*/&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;#include&nbsp;&lt;osg/GLExtensions&gt;&lt;br&nbsp;/&gt;<br>
#include&nbsp;&lt;osg/Node&gt;&lt;br&nbsp;/&gt;<br>
#include&nbsp;&lt;osg/Geometry&gt;&lt;br&nbsp;/&gt;<br>
#include&nbsp;&lt;osg/Notify&gt;&lt;br&nbsp;/&gt;<br>
#include&nbsp;&lt;osg/MatrixTransform&gt;&lt;br&nbsp;/&gt;<br>
#include&nbsp;&lt;osg/Texture2D&gt;&lt;br&nbsp;/&gt;<br>
#include&nbsp;&lt;osg/TextureRectangle&gt;&lt;br&nbsp;/&gt;<br>
#include&nbsp;&lt;osg/ColorMask&gt;&lt;br&nbsp;/&gt;<br>
#include&nbsp;&lt;osg/Material&gt;&lt;br&nbsp;/&gt;<br>
#include&nbsp;&lt;osg/Capability&gt;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;#include&nbsp;&lt;osgGA/TrackballManipulator&gt;&lt;br&nbsp;/&gt;<br>
#include&nbsp;&lt;osgGA/FlightManipulator&gt;&lt;br&nbsp;/&gt;<br>
#include&nbsp;&lt;osgGA/DriveManipulator&gt;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;#include&nbsp;&lt;osgViewer/Viewer&gt;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;#include&nbsp;&lt;iostream&gt;&lt;br&nbsp;/&gt;<br>
#include&nbsp;&lt;stdio.h&gt;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;#include&nbsp;&lt;osg/PolygonMode&gt;&lt;br&nbsp;/&gt;<br>
//#include&nbsp;&quot;RenderingUtility.h&quot;&nbsp;//to&nbsp;easily&nbsp;view&nbsp;intermediate&nbsp;textures&lt;br&nbsp;/&gt;<br>
//&lt;br&nbsp;/&gt;<br>
//&nbsp;Below&nbsp;is&nbsp;relatively&nbsp;straight&nbsp;forward&nbsp;example&nbsp;of&nbsp;using&nbsp;the&nbsp;OpenGL&nbsp;multiple&nbsp;render&nbsp;targets&nbsp;(MRT)&nbsp;extension&lt;br&nbsp;/&gt;<br>
//&nbsp;to&nbsp;FrameBufferObjects/GLSL&nbsp;shaders.&lt;br&nbsp;/&gt;<br>
//&lt;br&nbsp;/&gt;<br>
//&nbsp;Another,&nbsp;more&nbsp;sophisticated&nbsp;MRT&nbsp;example&nbsp;can&nbsp;be&nbsp;found&nbsp;in&nbsp;the&nbsp;osgstereomatch&nbsp;example.&lt;br&nbsp;/&gt;<br>
//&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::Geode&nbsp;*createScreenQuad(float&nbsp;width,&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&nbsp;float&nbsp;height,&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&nbsp;float&nbsp;scale,&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&nbsp;osg::Vec3&nbsp;corner)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
&#9;&#9;osg::Geometry*&nbsp;geom&nbsp;=&nbsp;osg::createTexturedQuadGeometry(&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;corner,&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;osg::Vec3(width,&nbsp;0,&nbsp;0),&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;osg::Vec3(0,&nbsp;height,&nbsp;0),&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;0,&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;0,&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;scale,&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;scale);&lt;br&nbsp;/&gt;<br>
&#9;&#9;osg::ref_ptr&lt;osg::Geode&gt;&nbsp;quad&nbsp;=&nbsp;new&nbsp;osg::Geode;&lt;br&nbsp;/&gt;<br>
&#9;&#9;quad-&gt;addDrawable(geom);&lt;br&nbsp;/&gt;<br>
&#9;&#9;int&nbsp;values&nbsp;=&nbsp;osg::StateAttribute::OFF&nbsp;|&nbsp;osg::StateAttribute::PROTECTED;&lt;br&nbsp;/&gt;<br>
&#9;&#9;quad-&gt;getOrCreateStateSet()-&gt;setAttribute(&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;new&nbsp;osg::PolygonMode(osg::PolygonMode::FRONT_AND_BACK,&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&nbsp;osg::PolygonMode::FILL),&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;values);&lt;br&nbsp;/&gt;<br>
&#9;&#9;quad-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING,&nbsp;values);&lt;br&nbsp;/&gt;<br>
&#9;&#9;return&nbsp;quad.release();&lt;br&nbsp;/&gt;<br>
}&lt;br&nbsp;/&gt;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::Camera&nbsp;*createHUDCamera(double&nbsp;left=0,&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&nbsp;double&nbsp;right=1,&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&nbsp;double&nbsp;bottom=0,&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&nbsp;double&nbsp;top=1)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
&#9;&#9;osg::ref_ptr&lt;osg::Camera&gt;&nbsp;camera&nbsp;=&nbsp;new&nbsp;osg::Camera;&lt;br&nbsp;/&gt;<br>
&#9;&#9;camera-&gt;setReferenceFrame(osg::Transform::ABSOLUTE_RF);&lt;br&nbsp;/&gt;<br>
&#9;&#9;camera-&gt;setClearMask(GL_DEPTH_BUFFER_BIT);&lt;br&nbsp;/&gt;<br>
&#9;&#9;camera-&gt;setRenderOrder(osg::Camera::POST_RENDER);&lt;br&nbsp;/&gt;<br>
&#9;&#9;camera-&gt;setAllowEventFocus(false);&lt;br&nbsp;/&gt;<br>
&#9;&#9;camera-&gt;setProjectionMatrix(osg::Matrix::ortho2D(left,&nbsp;right,&nbsp;bottom,&nbsp;top));&lt;br&nbsp;/&gt;<br>
&#9;&#9;camera-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING,&nbsp;osg::StateAttribute::OFF);&lt;br&nbsp;/&gt;<br>
&#9;&#9;return&nbsp;camera.release();&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::ref_ptr&lt;osg::Camera&gt;&nbsp;createTextureDisplayQuad(&lt;br&nbsp;/&gt;<br>
&#9;&#9;const&nbsp;osg::Vec3&nbsp;&amp;pos,&lt;br&nbsp;/&gt;<br>
&#9;&#9;osg::StateAttribute&nbsp;*tex,&lt;br&nbsp;/&gt;<br>
&#9;&#9;float&nbsp;scale,&lt;br&nbsp;/&gt;<br>
&#9;&#9;float&nbsp;width=0.3,&lt;br&nbsp;/&gt;<br>
&#9;&#9;float&nbsp;height=0.2)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
&#9;&#9;osg::ref_ptr&lt;osg::Camera&gt;&nbsp;hc&nbsp;=&nbsp;createHUDCamera();&lt;br&nbsp;/&gt;<br>
&#9;&#9;hc-&gt;addChild(createScreenQuad(width,&nbsp;height,&nbsp;scale,&nbsp;pos));&lt;br&nbsp;/&gt;<br>
&#9;&#9;hc-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0,&nbsp;tex);&lt;br&nbsp;/&gt;<br>
&#9;&#9;return&nbsp;hc;&lt;br&nbsp;/&gt;<br>
}&lt;br&nbsp;/&gt;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;The&nbsp;callback&nbsp;modifies&nbsp;an&nbsp;input&nbsp;image.&lt;br&nbsp;/&gt;<br>
struct&nbsp;MyCameraPostDrawCallback&nbsp;:&nbsp;public&nbsp;osg::Camera::DrawCallback&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
MyCameraPostDrawCallback(osg::Image*&nbsp;image):&lt;br&nbsp;/&gt;<br>
_image(image)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;virtual&nbsp;void&nbsp;operator&nbsp;()&nbsp;(const&nbsp;osg::Camera&amp;&nbsp;/*camera*/)&nbsp;const&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
if&nbsp;(_image&nbsp;&amp;&amp;&nbsp;_image-&gt;getPixelFormat()==GL_RGBA&nbsp;&amp;&amp;&nbsp;_image-&gt;getDataType()==GL_UNSIGNED_BYTE)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
//&nbsp;we'll&nbsp;pick&nbsp;out&nbsp;the&nbsp;center&nbsp;1/2&nbsp;of&nbsp;the&nbsp;whole&nbsp;image,&lt;br&nbsp;/&gt;<br>
int&nbsp;column_start&nbsp;=&nbsp;_image-&gt;s()/4;&lt;br&nbsp;/&gt;<br>
int&nbsp;column_end&nbsp;=&nbsp;3*column_start;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;int&nbsp;row_start&nbsp;=&nbsp;_image-&gt;t()/4;&lt;br&nbsp;/&gt;<br>
int&nbsp;row_end&nbsp;=&nbsp;3*row_start;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;and&nbsp;then&nbsp;halve&nbsp;their&nbsp;contribution&lt;br&nbsp;/&gt;<br>
for(int&nbsp;r=row_start;&nbsp;r&lt;row_end;&nbsp;++r)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
unsigned&nbsp;char*&nbsp;data&nbsp;=&nbsp;_image-&gt;data(column_start,&nbsp;r);&lt;br&nbsp;/&gt;<br>
for(int&nbsp;c=column_start;&nbsp;c&lt;column_end;&nbsp;++c)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
(*data)&nbsp;=&nbsp;(*data)/2;&nbsp;++data;&lt;br&nbsp;/&gt;<br>
(*data)&nbsp;=&nbsp;(*data)/2;&nbsp;++data;&lt;br&nbsp;/&gt;<br>
(*data)&nbsp;=&nbsp;(*data)/2;&nbsp;++data;&lt;br&nbsp;/&gt;<br>
(*data)&nbsp;=&nbsp;255;&nbsp;++data;&lt;br&nbsp;/&gt;<br>
}&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;_image-&gt;dirty();&lt;br&nbsp;/&gt;<br>
}&lt;br&nbsp;/&gt;<br>
else&nbsp;if&nbsp;(_image&nbsp;&amp;&amp;&nbsp;_image-&gt;getPixelFormat()==GL_RGBA&nbsp;&amp;&amp;&nbsp;_image-&gt;getDataType()==GL_FLOAT)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
//&nbsp;we'll&nbsp;pick&nbsp;out&nbsp;the&nbsp;center&nbsp;1/2&nbsp;of&nbsp;the&nbsp;whole&nbsp;image,&lt;br&nbsp;/&gt;<br>
int&nbsp;column_start&nbsp;=&nbsp;_image-&gt;s()/4;&lt;br&nbsp;/&gt;<br>
int&nbsp;column_end&nbsp;=&nbsp;3*column_start;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;int&nbsp;row_start&nbsp;=&nbsp;_image-&gt;t()/4;&lt;br&nbsp;/&gt;<br>
int&nbsp;row_end&nbsp;=&nbsp;3*row_start;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;and&nbsp;then&nbsp;halve&nbsp;their&nbsp;contribution&lt;br&nbsp;/&gt;<br>
for(int&nbsp;r=row_start;&nbsp;r&lt;row_end;&nbsp;++r)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
float*&nbsp;data&nbsp;=&nbsp;(float*)_image-&gt;data(column_start,&nbsp;r);&lt;br&nbsp;/&gt;<br>
for(int&nbsp;c=column_start;&nbsp;c&lt;column_end;&nbsp;++c)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
(*data)&nbsp;=&nbsp;(*data)/2.0;&nbsp;++data;&lt;br&nbsp;/&gt;<br>
(*data)&nbsp;=&nbsp;(*data)/2.0;&nbsp;++data;&lt;br&nbsp;/&gt;<br>
(*data)&nbsp;=&nbsp;(*data)/2.0;&nbsp;++data;&lt;br&nbsp;/&gt;<br>
(*data)&nbsp;=&nbsp;1.0f;&nbsp;++data;&lt;br&nbsp;/&gt;<br>
}&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;_image-&gt;dirty();&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//print&nbsp;out&nbsp;the&nbsp;first&nbsp;three&nbsp;values&lt;br&nbsp;/&gt;<br>
float*&nbsp;data&nbsp;=&nbsp;(float*)_image-&gt;data(0,&nbsp;0);&lt;br&nbsp;/&gt;<br>
fprintf(stderr,&quot;Float&nbsp;pixel&nbsp;data:&nbsp;r&nbsp;%e&nbsp;g&nbsp;%e&nbsp;b&nbsp;%e\n&quot;,&nbsp;data[0],&nbsp;data[1],&nbsp;data[2]);&lt;br&nbsp;/&gt;<br>
}&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::Image*&nbsp;_image;&lt;br&nbsp;/&gt;<br>
};&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;#define&nbsp;NUM_TEXTURES&nbsp;2&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;The&nbsp;quad&nbsp;geometry&nbsp;is&nbsp;used&nbsp;by&nbsp;the&nbsp;render&nbsp;to&nbsp;texture&nbsp;camera&nbsp;to&nbsp;generate&nbsp;multiple&nbsp;textures.&lt;br&nbsp;/&gt;<br>
osg::Group*&nbsp;createRTTQuad(unsigned&nbsp;int&nbsp;tex_width,&nbsp;unsigned&nbsp;int&nbsp;tex_height,&nbsp;bool&nbsp;useHDR)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
osg::Group&nbsp;*top_group&nbsp;=&nbsp;new&nbsp;osg::Group;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::ref_ptr&lt;osg::Geode&gt;&nbsp;quad_geode&nbsp;=&nbsp;new&nbsp;osg::Geode;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::ref_ptr&lt;osg::Vec3Array&gt;&nbsp;quad_coords&nbsp;=&nbsp;new&nbsp;osg::Vec3Array;&nbsp;//&nbsp;vertex&nbsp;coords&lt;br&nbsp;/&gt;<br>
//&nbsp;counter-clockwise&lt;br&nbsp;/&gt;<br>
quad_coords-&gt;push_back(osg::Vec3d(0,&nbsp;0,&nbsp;-1));&lt;br&nbsp;/&gt;<br>
quad_coords-&gt;push_back(osg::Vec3d(1,&nbsp;0,&nbsp;-1));&lt;br&nbsp;/&gt;<br>
quad_coords-&gt;push_back(osg::Vec3d(1,&nbsp;1,&nbsp;-1));&lt;br&nbsp;/&gt;<br>
quad_coords-&gt;push_back(osg::Vec3d(0,&nbsp;1,&nbsp;-1));&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::ref_ptr&lt;osg::Vec2Array&gt;&nbsp;quad_tcoords&nbsp;=&nbsp;new&nbsp;osg::Vec2Array;&nbsp;//&nbsp;texture&nbsp;coords&lt;br&nbsp;/&gt;<br>
quad_tcoords-&gt;push_back(osg::Vec2(0,&nbsp;0));&lt;br&nbsp;/&gt;<br>
quad_tcoords-&gt;push_back(osg::Vec2(tex_width,&nbsp;0));&lt;br&nbsp;/&gt;<br>
quad_tcoords-&gt;push_back(osg::Vec2(tex_width,&nbsp;tex_height));&lt;br&nbsp;/&gt;<br>
quad_tcoords-&gt;push_back(osg::Vec2(0,&nbsp;tex_height));&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::ref_ptr&lt;osg::Geometry&gt;&nbsp;quad_geom&nbsp;=&nbsp;new&nbsp;osg::Geometry;&lt;br&nbsp;/&gt;<br>
osg::ref_ptr&lt;osg::DrawArrays&gt;&nbsp;quad_da&nbsp;=&nbsp;new&nbsp;osg::DrawArrays(osg::PrimitiveSet::QUADS,0,4);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::ref_ptr&lt;osg::Vec4Array&gt;&nbsp;quad_colors&nbsp;=&nbsp;new&nbsp;osg::Vec4Array;&lt;br&nbsp;/&gt;<br>
quad_colors-&gt;push_back(osg::Vec4(1.0f,1.0f,1.0f,1.0f));&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;quad_geom-&gt;setVertexArray(quad_coords.get());&lt;br&nbsp;/&gt;<br>
quad_geom-&gt;setTexCoordArray(0,&nbsp;quad_tcoords.get());&lt;br&nbsp;/&gt;<br>
quad_geom-&gt;addPrimitiveSet(quad_da.get());&lt;br&nbsp;/&gt;<br>
quad_geom-&gt;setColorArray(quad_colors.get(),&nbsp;osg::Array::BIND_OVERALL);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::StateSet&nbsp;*stateset&nbsp;=&nbsp;quad_geom-&gt;getOrCreateStateSet();&lt;br&nbsp;/&gt;<br>
stateset-&gt;setMode(GL_LIGHTING,osg::StateAttribute::OFF);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;stateset-&gt;addUniform(new&nbsp;osg::Uniform(&quot;width&quot;,&nbsp;(int)tex_width));&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;Attach&nbsp;shader,&nbsp;glFragData&nbsp;is&nbsp;used&nbsp;to&nbsp;create&nbsp;data&nbsp;for&nbsp;multiple&nbsp;render&nbsp;targets&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;if&nbsp;(useHDR)&nbsp;{&lt;br&nbsp;/&gt;<br>
static&nbsp;const&nbsp;char&nbsp;*shaderSource&nbsp;=&nbsp;{&lt;br&nbsp;/&gt;<br>
&quot;uniform&nbsp;int&nbsp;width;&quot;&lt;br&nbsp;/&gt;<br>
&quot;void&nbsp;main(void)\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;{\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;gl_FragData[0]&nbsp;=&nbsp;vec4(-1e-12,0,0,1);\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;gl_FragData[1]&nbsp;=&nbsp;vec4(0,1e-12,0,1);\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;gl_FragData[2]&nbsp;=&nbsp;vec4(0,0,1e-12,1);\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;gl_FragData[3]&nbsp;=&nbsp;vec4(0,0,1e-12,1);\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;}\n&quot;&lt;br&nbsp;/&gt;<br>
};&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::ref_ptr&lt;osg::Shader&gt;&nbsp;fshader&nbsp;=&nbsp;new&nbsp;osg::Shader(&nbsp;osg::Shader::FRAGMENT&nbsp;,&nbsp;shaderSource);&lt;br&nbsp;/&gt;<br>
osg::ref_ptr&lt;osg::Program&gt;&nbsp;program&nbsp;=&nbsp;new&nbsp;osg::Program;&lt;br&nbsp;/&gt;<br>
program-&gt;addShader(fshader.get());&lt;br&nbsp;/&gt;<br>
stateset-&gt;setAttributeAndModes(program.get(),&nbsp;osg::StateAttribute::ON&nbsp;|&nbsp;osg::StateAttribute::OVERRIDE&nbsp;);&lt;br&nbsp;/&gt;<br>
}&nbsp;else&nbsp;{&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;static&nbsp;const&nbsp;char&nbsp;*shaderSource&nbsp;=&nbsp;{&lt;br&nbsp;/&gt;<br>
&quot;uniform&nbsp;int&nbsp;width;&quot;&lt;br&nbsp;/&gt;<br>
&quot;void&nbsp;main(void)\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;{\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;gl_FragData[0]&nbsp;=&nbsp;vec4(1,0,0,1);\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;gl_FragData[1]&nbsp;=&nbsp;vec4(0,1,0,1);\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;gl_FragData[2]&nbsp;=&nbsp;vec4(0,0,1,1);\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;gl_FragData[3]&nbsp;=&nbsp;vec4(0,0,1,1);\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;}\n&quot;&lt;br&nbsp;/&gt;<br>
};&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::ref_ptr&lt;osg::Shader&gt;&nbsp;fshader&nbsp;=&nbsp;new&nbsp;osg::Shader(&nbsp;osg::Shader::FRAGMENT&nbsp;,&nbsp;shaderSource);&lt;br&nbsp;/&gt;<br>
osg::ref_ptr&lt;osg::Program&gt;&nbsp;program&nbsp;=&nbsp;new&nbsp;osg::Program;&lt;br&nbsp;/&gt;<br>
program-&gt;addShader(fshader.get());&lt;br&nbsp;/&gt;<br>
stateset-&gt;setAttributeAndModes(program.get(),&nbsp;osg::StateAttribute::ON&nbsp;|&nbsp;osg::StateAttribute::OVERRIDE&nbsp;);&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;quad_geode-&gt;addDrawable(quad_geom.get());&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;top_group-&gt;addChild(quad_geode.get());&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;return&nbsp;top_group;&lt;br&nbsp;/&gt;<br>
}&lt;br&nbsp;/&gt;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;&#9;&#9;osg::TextureRectangle*&nbsp;textureRect[NUM_TEXTURES]&nbsp;=&nbsp;{0,0};&nbsp;//moved&nbsp;to&nbsp;global&nbsp;scope&nbsp;to&nbsp;easily&nbsp;view&nbsp;intermediate&nbsp;textures&lt;br&nbsp;/&gt;<br>
//&nbsp;Here&nbsp;a&nbsp;scene&nbsp;consisting&nbsp;of&nbsp;a&nbsp;single&nbsp;quad&nbsp;is&nbsp;created.&nbsp;This&nbsp;scene&nbsp;is&nbsp;viewed&nbsp;by&nbsp;the&nbsp;screen&nbsp;camera.&lt;br&nbsp;/&gt;<br>
//&nbsp;The&nbsp;quad&nbsp;is&nbsp;textured&nbsp;using&nbsp;a&nbsp;shader&nbsp;and&nbsp;the&nbsp;multiple&nbsp;textures&nbsp;generated&nbsp;in&nbsp;the&nbsp;RTT&nbsp;stage.&lt;br&nbsp;/&gt;<br>
osg::Node*&nbsp;createScene(osg::Node*&nbsp;cam_subgraph,&nbsp;unsigned&nbsp;int&nbsp;tex_width,&nbsp;unsigned&nbsp;int&nbsp;tex_height,&nbsp;bool&nbsp;useHDR,&nbsp;bool&nbsp;useImage,&nbsp;bool&nbsp;useMultiSample)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
if&nbsp;(!cam_subgraph)&nbsp;return&nbsp;0;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;create&nbsp;a&nbsp;group&nbsp;to&nbsp;contain&nbsp;the&nbsp;quad&nbsp;and&nbsp;the&nbsp;pre&nbsp;render&nbsp;camera.&lt;br&nbsp;/&gt;<br>
osg::Group*&nbsp;parent&nbsp;=&nbsp;new&nbsp;osg::Group;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;textures&nbsp;to&nbsp;render&nbsp;to&nbsp;and&nbsp;to&nbsp;use&nbsp;for&nbsp;texturing&nbsp;of&nbsp;the&nbsp;final&nbsp;quad&lt;br&nbsp;/&gt;<br>
&#9;&#9;//osg::TextureRectangle*&nbsp;textureRect[NUM_TEXTURES]&nbsp;=&nbsp;{0,0,0,0};&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;for&nbsp;(int&nbsp;i=0;i&lt;NUM_TEXTURES;i++)&nbsp;{&lt;br&nbsp;/&gt;<br>
textureRect[i]&nbsp;=&nbsp;new&nbsp;osg::TextureRectangle;&lt;br&nbsp;/&gt;<br>
textureRect[i]-&gt;setTextureSize(tex_width,&nbsp;tex_height);&lt;br&nbsp;/&gt;<br>
textureRect[i]-&gt;setInternalFormat(GL_RGBA);&lt;br&nbsp;/&gt;<br>
textureRect[i]-&gt;setFilter(osg::Texture2D::MIN_FILTER,osg::Texture2D::LINEAR);&lt;br&nbsp;/&gt;<br>
textureRect[i]-&gt;setFilter(osg::Texture2D::MAG_FILTER,osg::Texture2D::LINEAR);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;if&nbsp;(useHDR)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
//&nbsp;Default&nbsp;HDR&nbsp;format&lt;br&nbsp;/&gt;<br>
textureRect[i]-&gt;setInternalFormat(GL_RGBA32F_ARB);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;GL_FLOAT_RGBA32_NV&nbsp;might&nbsp;be&nbsp;supported&nbsp;on&nbsp;pre&nbsp;8-series&nbsp;GPUs&lt;br&nbsp;/&gt;<br>
//textureRect[i]-&gt;setInternalFormat(GL_FLOAT_RGBA32_NV);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;GL_RGBA16F_ARB&nbsp;can&nbsp;be&nbsp;used&nbsp;with&nbsp;this&nbsp;example,&lt;br&nbsp;/&gt;<br>
//&nbsp;but&nbsp;modify&nbsp;e-12&nbsp;and&nbsp;e12&nbsp;in&nbsp;the&nbsp;shaders&nbsp;accordingly&lt;br&nbsp;/&gt;<br>
//textureRect[i]-&gt;setInternalFormat(GL_RGBA16F_ARB);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;textureRect[i]-&gt;setSourceFormat(GL_RGBA);&lt;br&nbsp;/&gt;<br>
textureRect[i]-&gt;setSourceType(GL_FLOAT);&lt;br&nbsp;/&gt;<br>
}&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;first&nbsp;create&nbsp;the&nbsp;geometry&nbsp;of&nbsp;the&nbsp;quad&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
osg::Geometry*&nbsp;polyGeom&nbsp;=&nbsp;new&nbsp;osg::Geometry();&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;polyGeom-&gt;setSupportsDisplayList(false);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::Vec3Array*&nbsp;vertices&nbsp;=&nbsp;new&nbsp;osg::Vec3Array;&lt;br&nbsp;/&gt;<br>
osg::Vec2Array*&nbsp;texcoords&nbsp;=&nbsp;new&nbsp;osg::Vec2Array;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;vertices-&gt;push_back(osg::Vec3d(0,0,0));&lt;br&nbsp;/&gt;<br>
texcoords-&gt;push_back(osg::Vec2(0,0));&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;vertices-&gt;push_back(osg::Vec3d(1,0,0));&lt;br&nbsp;/&gt;<br>
texcoords-&gt;push_back(osg::Vec2(tex_width,0));&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;vertices-&gt;push_back(osg::Vec3d(1,0,1));&lt;br&nbsp;/&gt;<br>
texcoords-&gt;push_back(osg::Vec2(tex_width,tex_height));&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;vertices-&gt;push_back(osg::Vec3d(0,0,1));&lt;br&nbsp;/&gt;<br>
texcoords-&gt;push_back(osg::Vec2(0,tex_height));&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;polyGeom-&gt;setVertexArray(vertices);&lt;br&nbsp;/&gt;<br>
polyGeom-&gt;setTexCoordArray(0,texcoords);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::Vec4Array*&nbsp;colors&nbsp;=&nbsp;new&nbsp;osg::Vec4Array;&lt;br&nbsp;/&gt;<br>
colors-&gt;push_back(osg::Vec4(1.0f,1.0f,1.0f,1.0f));&lt;br&nbsp;/&gt;<br>
polyGeom-&gt;setColorArray(colors,&nbsp;osg::Array::BIND_OVERALL);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;polyGeom-&gt;addPrimitiveSet(new&nbsp;osg::DrawArrays(osg::PrimitiveSet::QUADS,0,vertices-&gt;size()));&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;now&nbsp;we&nbsp;need&nbsp;to&nbsp;add&nbsp;the&nbsp;textures&nbsp;(generated&nbsp;by&nbsp;RTT)&nbsp;to&nbsp;the&nbsp;Drawable.&lt;br&nbsp;/&gt;<br>
osg::StateSet*&nbsp;stateset&nbsp;=&nbsp;new&nbsp;osg::StateSet;&lt;br&nbsp;/&gt;<br>
for&nbsp;(int&nbsp;i=0;i&lt;NUM_TEXTURES;i++){&lt;br&nbsp;/&gt;<br>
stateset-&gt;setTextureAttributeAndModes(i,&nbsp;textureRect[i],&nbsp;osg::StateAttribute::ON);&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;polyGeom-&gt;setStateSet(stateset);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;Attach&nbsp;a&nbsp;shader&nbsp;to&nbsp;the&nbsp;final&nbsp;quad&nbsp;to&nbsp;combine&nbsp;the&nbsp;input&nbsp;textures.&lt;br&nbsp;/&gt;<br>
if&nbsp;(useHDR)&nbsp;{&lt;br&nbsp;/&gt;<br>
static&nbsp;const&nbsp;char&nbsp;*shaderSource&nbsp;=&nbsp;{&lt;br&nbsp;/&gt;<br>
&quot;uniform&nbsp;sampler2DRect&nbsp;textureID0;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;uniform&nbsp;sampler2DRect&nbsp;textureID1;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;uniform&nbsp;sampler2DRect&nbsp;textureID2;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;uniform&nbsp;sampler2DRect&nbsp;textureID3;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;uniform&nbsp;float&nbsp;width;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;uniform&nbsp;float&nbsp;height;&nbsp;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;void&nbsp;main(void)\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;{\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;gl_FragData[0]&nbsp;=&nbsp;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;vec4(&nbsp;-1e12&nbsp;*&nbsp;texture2DRect(&nbsp;textureID0,&nbsp;gl_TexCoord[0].st&nbsp;).rgb,&nbsp;1)&nbsp;+&nbsp;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;vec4(&nbsp;1e12&nbsp;*&nbsp;texture2DRect(&nbsp;textureID1,&nbsp;gl_TexCoord[0].st&nbsp;).rgb,&nbsp;1)&nbsp;+&nbsp;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;vec4(&nbsp;1e12&nbsp;*&nbsp;texture2DRect(&nbsp;textureID2,&nbsp;gl_TexCoord[0].st&nbsp;).rgb,&nbsp;1)&nbsp;+&nbsp;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;vec4(-0.5e12&nbsp;*&nbsp;texture2DRect(&nbsp;textureID3,&nbsp;gl_TexCoord[0].st&nbsp;).rgb,&nbsp;1);&nbsp;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;}\n&quot;&lt;br&nbsp;/&gt;<br>
};&lt;br&nbsp;/&gt;<br>
osg::ref_ptr&lt;osg::Shader&gt;&nbsp;fshader&nbsp;=&nbsp;new&nbsp;osg::Shader(&nbsp;osg::Shader::FRAGMENT&nbsp;,&nbsp;shaderSource);&lt;br&nbsp;/&gt;<br>
osg::ref_ptr&lt;osg::Program&gt;&nbsp;program&nbsp;=&nbsp;new&nbsp;osg::Program;&lt;br&nbsp;/&gt;<br>
program-&gt;addShader(&nbsp;fshader.get());&lt;br&nbsp;/&gt;<br>
stateset-&gt;setAttributeAndModes(&nbsp;program.get(),&nbsp;osg::StateAttribute::ON&nbsp;|&nbsp;osg::StateAttribute::OVERRIDE&nbsp;);&lt;br&nbsp;/&gt;<br>
}&nbsp;else&nbsp;{&lt;br&nbsp;/&gt;<br>
static&nbsp;const&nbsp;char&nbsp;*shaderSource&nbsp;=&nbsp;{&lt;br&nbsp;/&gt;<br>
&quot;uniform&nbsp;sampler2DRect&nbsp;textureID0;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;uniform&nbsp;sampler2DRect&nbsp;textureID1;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;uniform&nbsp;sampler2DRect&nbsp;textureID2;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;uniform&nbsp;sampler2DRect&nbsp;textureID3;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;void&nbsp;main(void)\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;{\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;gl_FragData[0]&nbsp;=&nbsp;\n&quot;&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&quot;&nbsp;vec4(texture2DRect(&nbsp;textureID0,&nbsp;gl_TexCoord[0].st&nbsp;).rgb,&nbsp;1)&nbsp;+&nbsp;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;vec4(texture2DRect(&nbsp;textureID1,&nbsp;gl_TexCoord[0].st&nbsp;).rgb,&nbsp;1)&nbsp;+&nbsp;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;vec4(texture2DRect(&nbsp;textureID2,&nbsp;gl_TexCoord[0].st&nbsp;).rgb,&nbsp;1)&nbsp;+&nbsp;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;&nbsp;-0.5*vec4(texture2DRect(&nbsp;textureID3,&nbsp;gl_TexCoord[0].st&nbsp;).rgb,&nbsp;1);&nbsp;\n&quot;&lt;br&nbsp;/&gt;<br>
&quot;}\n&quot;&lt;br&nbsp;/&gt;<br>
};&lt;br&nbsp;/&gt;<br>
osg::ref_ptr&lt;osg::Shader&gt;&nbsp;fshader&nbsp;=&nbsp;new&nbsp;osg::Shader(&nbsp;osg::Shader::FRAGMENT&nbsp;,&nbsp;shaderSource);&lt;br&nbsp;/&gt;<br>
osg::ref_ptr&lt;osg::Program&gt;&nbsp;program&nbsp;=&nbsp;new&nbsp;osg::Program;&lt;br&nbsp;/&gt;<br>
program-&gt;addShader(&nbsp;fshader.get());&lt;br&nbsp;/&gt;<br>
stateset-&gt;setAttributeAndModes(&nbsp;program.get(),&nbsp;osg::StateAttribute::ON&nbsp;|&nbsp;osg::StateAttribute::OVERRIDE&nbsp;);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;stateset-&gt;addUniform(new&nbsp;osg::Uniform(&quot;textureID0&quot;,&nbsp;0));&lt;br&nbsp;/&gt;<br>
stateset-&gt;addUniform(new&nbsp;osg::Uniform(&quot;textureID1&quot;,&nbsp;1));&lt;br&nbsp;/&gt;<br>
stateset-&gt;addUniform(new&nbsp;osg::Uniform(&quot;textureID2&quot;,&nbsp;2));&lt;br&nbsp;/&gt;<br>
stateset-&gt;addUniform(new&nbsp;osg::Uniform(&quot;textureID3&quot;,&nbsp;3));&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//stateset-&gt;setDataVariance(osg::Object::DYNAMIC);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::Geode*&nbsp;geode&nbsp;=&nbsp;new&nbsp;osg::Geode();&lt;br&nbsp;/&gt;<br>
geode-&gt;addDrawable(polyGeom);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;parent-&gt;addChild(geode);&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;now&nbsp;create&nbsp;the&nbsp;camera&nbsp;to&nbsp;do&nbsp;the&nbsp;multiple&nbsp;render&nbsp;to&nbsp;texture&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
osg::Camera*&nbsp;camera&nbsp;=&nbsp;new&nbsp;osg::Camera;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;set&nbsp;up&nbsp;the&nbsp;background&nbsp;color&nbsp;and&nbsp;clear&nbsp;mask.&lt;br&nbsp;/&gt;<br>
camera-&gt;setClearColor(osg::Vec4(0.1f,0.1f,0.3f,1.0f));&lt;br&nbsp;/&gt;<br>
camera-&gt;setClearMask(GL_COLOR_BUFFER_BIT&nbsp;|&nbsp;GL_DEPTH_BUFFER_BIT);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;the&nbsp;camera&nbsp;is&nbsp;going&nbsp;to&nbsp;look&nbsp;at&nbsp;our&nbsp;input&nbsp;quad&lt;br&nbsp;/&gt;<br>
camera-&gt;setProjectionMatrix(osg::Matrix::ortho2D(0,1,0,1));&lt;br&nbsp;/&gt;<br>
camera-&gt;setReferenceFrame(osg::Transform::ABSOLUTE_RF);&lt;br&nbsp;/&gt;<br>
camera-&gt;setViewMatrix(osg::Matrix::identity());&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;set&nbsp;viewport&lt;br&nbsp;/&gt;<br>
camera-&gt;setViewport(0,&nbsp;0,&nbsp;tex_width,&nbsp;tex_height);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;set&nbsp;the&nbsp;camera&nbsp;to&nbsp;render&nbsp;before&nbsp;the&nbsp;main&nbsp;camera.&lt;br&nbsp;/&gt;<br>
camera-&gt;setRenderOrder(osg::Camera::PRE_RENDER);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;tell&nbsp;the&nbsp;camera&nbsp;to&nbsp;use&nbsp;OpenGL&nbsp;frame&nbsp;buffer&nbsp;objects&lt;br&nbsp;/&gt;<br>
camera-&gt;setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;attach&nbsp;the&nbsp;textures&nbsp;to&nbsp;use&lt;br&nbsp;/&gt;<br>
for&nbsp;(int&nbsp;i=0;&nbsp;i&lt;NUM_TEXTURES;&nbsp;i++)&nbsp;{&lt;br&nbsp;/&gt;<br>
if&nbsp;(useMultiSample)&lt;br&nbsp;/&gt;<br>
camera-&gt;attach(osg::Camera::BufferComponent(osg::Camera::COLOR_BUFFER0+i),&nbsp;textureRect[i],&nbsp;0,&nbsp;0,&nbsp;false,&nbsp;4,&nbsp;4);&lt;br&nbsp;/&gt;<br>
else&lt;br&nbsp;/&gt;<br>
camera-&gt;attach(osg::Camera::BufferComponent(osg::Camera::COLOR_BUFFER0+i),&nbsp;textureRect[i]);&lt;br&nbsp;/&gt;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;#if&nbsp;0&lt;br&nbsp;/&gt;<br>
//&nbsp;test&nbsp;for&nbsp;new&nbsp;glEnablei/glDisablei&nbsp;functionality.&lt;br&nbsp;/&gt;<br>
camera-&gt;getOrCreateStateSet()-&gt;setAttribute(new&nbsp;osg::Enablei(GL_BLEND,&nbsp;0));&lt;br&nbsp;/&gt;<br>
camera-&gt;getOrCreateStateSet()-&gt;setAttribute(new&nbsp;osg::Disablei(GL_BLEND,&nbsp;1));&lt;br&nbsp;/&gt;<br>
#endif&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;we&nbsp;can&nbsp;also&nbsp;read&nbsp;back&nbsp;any&nbsp;of&nbsp;the&nbsp;targets&nbsp;as&nbsp;an&nbsp;image,&nbsp;modify&nbsp;this&nbsp;image&nbsp;and&nbsp;push&nbsp;it&nbsp;back&lt;br&nbsp;/&gt;<br>
if&nbsp;(useImage)&nbsp;{&lt;br&nbsp;/&gt;<br>
//&nbsp;which&nbsp;texture&nbsp;to&nbsp;get&nbsp;the&nbsp;image&nbsp;from&lt;br&nbsp;/&gt;<br>
const&nbsp;int&nbsp;tex_to_get&nbsp;=&nbsp;0;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::Image*&nbsp;image&nbsp;=&nbsp;new&nbsp;osg::Image;&lt;br&nbsp;/&gt;<br>
if&nbsp;(useHDR)&nbsp;{&lt;br&nbsp;/&gt;<br>
image-&gt;allocateImage(tex_width,&nbsp;tex_height,&nbsp;1,&nbsp;GL_RGBA,&nbsp;GL_FLOAT);&lt;br&nbsp;/&gt;<br>
}&nbsp;else&nbsp;{&lt;br&nbsp;/&gt;<br>
image-&gt;allocateImage(tex_width,&nbsp;tex_height,&nbsp;1,&nbsp;GL_RGBA,&nbsp;GL_UNSIGNED_BYTE);&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;attach&nbsp;the&nbsp;image&nbsp;so&nbsp;its&nbsp;copied&nbsp;on&nbsp;each&nbsp;frame.&lt;br&nbsp;/&gt;<br>
camera-&gt;attach(osg::Camera::BufferComponent(osg::Camera::COLOR_BUFFER0&nbsp;+&nbsp;tex_to_get),&nbsp;image);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;camera-&gt;setPostDrawCallback(new&nbsp;MyCameraPostDrawCallback(image));&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;push&nbsp;back&nbsp;the&nbsp;image&nbsp;to&nbsp;the&nbsp;texture&lt;br&nbsp;/&gt;<br>
textureRect[tex_to_get]-&gt;setImage(0,&nbsp;image);&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;add&nbsp;the&nbsp;subgraph&nbsp;to&nbsp;render&lt;br&nbsp;/&gt;<br>
camera-&gt;addChild(cam_subgraph);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;parent-&gt;addChild(camera);&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;return&nbsp;parent;&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;int&nbsp;main(&nbsp;int&nbsp;argc,&nbsp;char&nbsp;**argv&nbsp;)&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
//&nbsp;use&nbsp;an&nbsp;ArgumentParser&nbsp;object&nbsp;to&nbsp;manage&nbsp;the&nbsp;program&nbsp;arguments.&lt;br&nbsp;/&gt;<br>
osg::ArgumentParser&nbsp;arguments(&amp;argc,argv);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;set&nbsp;up&nbsp;the&nbsp;usage&nbsp;document,&nbsp;in&nbsp;case&nbsp;we&nbsp;need&nbsp;to&nbsp;print&nbsp;out&nbsp;how&nbsp;to&nbsp;use&nbsp;this&nbsp;program.&lt;br&nbsp;/&gt;<br>
arguments.getApplicationUsage()-&gt;setDescription(arguments.getApplicationName()&nbsp;+&nbsp;&quot;&nbsp;demonstrates&nbsp;the&nbsp;use&nbsp;of&nbsp;multiple&nbsp;render&nbsp;targets&nbsp;(MRT)&nbsp;with&nbsp;frame&nbsp;buffer&nbsp;objects&nbsp;(FBOs).&nbsp;A&nbsp;render&nbsp;to&nbsp;texture&nbsp;(RTT)&nbsp;camera&nbsp;is&nbsp;used&nbsp;to&nbsp;render&nbsp;to&nbsp;four&nbsp;textures&nbsp;using&nbsp;a&nbsp;single&nbsp;shader.&nbsp;The&nbsp;four&nbsp;textures&nbsp;are&nbsp;then&nbsp;combined&nbsp;to&nbsp;texture&nbsp;the&nbsp;viewed&nbsp;geometry.&quot;);&lt;br&nbsp;/&gt;<br>
arguments.getApplicationUsage()-&gt;setCommandLineUsage(arguments.getApplicationName()+&quot;&nbsp;[options]&nbsp;...&quot;);&lt;br&nbsp;/&gt;<br>
arguments.getApplicationUsage()-&gt;addCommandLineOption(&quot;-h&nbsp;or&nbsp;--help&quot;,&quot;Display&nbsp;this&nbsp;information.&quot;);&lt;br&nbsp;/&gt;<br>
arguments.getApplicationUsage()-&gt;addCommandLineOption(&quot;--width&quot;,&quot;Set&nbsp;the&nbsp;width&nbsp;of&nbsp;the&nbsp;render&nbsp;to&nbsp;texture.&quot;);&lt;br&nbsp;/&gt;<br>
arguments.getApplicationUsage()-&gt;addCommandLineOption(&quot;--height&quot;,&quot;Set&nbsp;the&nbsp;height&nbsp;of&nbsp;the&nbsp;render&nbsp;to&nbsp;texture.&quot;);&lt;br&nbsp;/&gt;<br>
arguments.getApplicationUsage()-&gt;addCommandLineOption(&quot;--image&quot;,&quot;Render&nbsp;one&nbsp;of&nbsp;the&nbsp;targets&nbsp;to&nbsp;an&nbsp;image,&nbsp;then&nbsp;apply&nbsp;a&nbsp;post&nbsp;draw&nbsp;callback&nbsp;to&nbsp;modify&nbsp;it&nbsp;and&nbsp;use&nbsp;this&nbsp;image&nbsp;to&nbsp;update&nbsp;the&nbsp;final&nbsp;texture.&nbsp;Print&nbsp;some&nbsp;texture&nbsp;values&nbsp;when&nbsp;using&nbsp;HDR.&quot;);&lt;br&nbsp;/&gt;<br>
arguments.getApplicationUsage()-&gt;addCommandLineOption(&quot;--hdr&quot;,&quot;Use&nbsp;high&nbsp;dynamic&nbsp;range&nbsp;(HDR).&nbsp;Create&nbsp;floating&nbsp;point&nbsp;textures&nbsp;to&nbsp;render&nbsp;to.&quot;);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;construct&nbsp;the&nbsp;viewer.&lt;br&nbsp;/&gt;<br>
osgViewer::Viewer&nbsp;viewer(arguments);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;//&nbsp;if&nbsp;user&nbsp;request&nbsp;help&nbsp;write&nbsp;it&nbsp;out&nbsp;to&nbsp;cout.&lt;br&nbsp;/&gt;<br>
if&nbsp;(arguments.read(&quot;-h&quot;)&nbsp;||&nbsp;arguments.read(&quot;--help&quot;))&lt;br&nbsp;/&gt;<br>
{&lt;br&nbsp;/&gt;<br>
arguments.getApplicationUsage()-&gt;write(std::cout);&lt;br&nbsp;/&gt;<br>
return&nbsp;1;&lt;br&nbsp;/&gt;<br>
}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;unsigned&nbsp;tex_width&nbsp;=&nbsp;512;&lt;br&nbsp;/&gt;<br>
unsigned&nbsp;tex_height&nbsp;=&nbsp;512;&lt;br&nbsp;/&gt;<br>
while&nbsp;(arguments.read(&quot;--width&quot;,&nbsp;tex_width))&nbsp;{}&lt;br&nbsp;/&gt;<br>
while&nbsp;(arguments.read(&quot;--height&quot;,&nbsp;tex_height))&nbsp;{}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;bool&nbsp;useHDR&nbsp;=&nbsp;false;&lt;br&nbsp;/&gt;<br>
while&nbsp;(arguments.read(&quot;--hdr&quot;))&nbsp;{&nbsp;useHDR&nbsp;=&nbsp;true;&nbsp;}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;bool&nbsp;useImage&nbsp;=&nbsp;false;&lt;br&nbsp;/&gt;<br>
while&nbsp;(arguments.read(&quot;--image&quot;))&nbsp;{&nbsp;useImage&nbsp;=&nbsp;true;&nbsp;}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;bool&nbsp;useMultiSample&nbsp;=&nbsp;false;&lt;br&nbsp;/&gt;<br>
while&nbsp;(arguments.read(&quot;--ms&quot;))&nbsp;{&nbsp;useMultiSample&nbsp;=&nbsp;true;&nbsp;}&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::Group*&nbsp;subGraph&nbsp;=&nbsp;createRTTQuad(tex_width,&nbsp;tex_height,&nbsp;useHDR);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;osg::Group*&nbsp;rootNode&nbsp;=&nbsp;new&nbsp;osg::Group();&lt;br&nbsp;/&gt;<br>
rootNode-&gt;addChild(createScene(subGraph,&nbsp;tex_width,&nbsp;tex_height,&nbsp;useHDR,&nbsp;useImage,&nbsp;useMultiSample));&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;&#9;&#9;rootNode-&gt;addChild(createScene(subGraph,&nbsp;tex_width,&nbsp;tex_height,&nbsp;useHDR,&nbsp;useImage,&nbsp;useMultiSample));&lt;br&nbsp;/&gt;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;&#9;//Some&nbsp;code&nbsp;to&nbsp;view&nbsp;the&nbsp;intermediate&nbsp;textures&lt;br&nbsp;/&gt;<br>
&#9;&#9;&nbsp;osg::ref_ptr&lt;osg::Camera&gt;&nbsp;testTex&nbsp;=&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;createTextureDisplayQuad(osg::Vec3(0,&nbsp;0.7,&nbsp;0),&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&nbsp;textureRect[0],&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&nbsp;tex_width);&lt;br&nbsp;/&gt;<br>
osg::ref_ptr&lt;osg::Camera&gt;&nbsp;testTex2&nbsp;=&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;createTextureDisplayQuad(osg::Vec3(0,&nbsp;0.35,&nbsp;0),&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&nbsp;textureRect[1],&lt;br&nbsp;/&gt;<br>
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&nbsp;tex_width);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;rootNode-&gt;addChild(testTex);&lt;br&nbsp;/&gt;<br>
rootNode-&gt;addChild(testTex2);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;&#9;&#9;//&nbsp;add&nbsp;model&nbsp;to&nbsp;the&nbsp;viewer.&lt;br&nbsp;/&gt;<br>
&#9;&#9;viewer.setSceneData(&nbsp;rootNode&nbsp;);&lt;br&nbsp;/&gt;<br>
&#9;&#9;viewer.realize();&lt;br&nbsp;/&gt;<br>
&#9;&#9;viewer.getCamera()-&gt;getGraphicsContext()-&gt;getState()-&gt;setUseVertexAttributeAliasing(true);&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;&#9;&#9;return&nbsp;&lt;a&nbsp;href=&quot;http://viewer.run&quot;&gt;viewer.run&lt;/a&gt;();&lt;br&nbsp;/&gt;<br>
}&lt;br&nbsp;/&gt;&lt;br&nbsp;/&gt;&lt;br&nbsp;/&gt;&lt;br&nbsp;/&gt;&lt;br&nbsp;/&gt;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;Thank&nbsp;you!!&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;Cheers,&lt;br&nbsp;/&gt;<br>
antiro[/code]&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;------------------&lt;br&nbsp;/&gt;<br>
Read&nbsp;this&nbsp;topic&nbsp;online&nbsp;here:&lt;br&nbsp;/&gt;<br>
&lt;a&nbsp;href=&quot;http://forum.openscenegraph.org/viewtopic.php?p=71613#71613&quot;&gt;http://forum.openscenegraph.org/viewtopic.php?p=71613#71613&lt;/a&gt;&lt;br&nbsp;/&gt;&lt;br&nbsp;/&gt;&lt;br&nbsp;/&gt;&lt;br&nbsp;/&gt;&lt;/p&gt;<br>
&lt;p&nbsp;dir=&quot;ltr&quot;&gt;_______________________________________________&lt;br&nbsp;/&gt;<br>
osg-users&nbsp;mailing&nbsp;list&lt;br&nbsp;/&gt;<br>
&lt;a&nbsp;href=&quot;mailto:osg-users@lists.openscenegraph.org&quot;&gt;osg-users@lists.openscenegraph.org&lt;/a&gt;&lt;br&nbsp;/&gt;<br>
&lt;a&nbsp;href=&quot;http://lists.openscenegraph.org/listinfo.cgi/osg-users-openscenegraph.org&quot;&gt;http://lists.openscenegraph.org/listinfo.cgi/osg-users-openscenegraph.org&lt;/a&gt;&lt;br&nbsp;/&gt;<br>
&lt;/p&gt;<br>
&lt;/blockquote&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;/body&gt;&lt;/html&gt;<br>

</tt>
